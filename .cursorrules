# CrateTrackerZK 项目规则文档

## 项目概述

**CrateTrackerZK** 是一个魔兽世界插件，用于自动追踪战争物资空投箱的刷新时间和位面信息。

**核心功能**：
- 自动检测：通过地图图标（Vignette）系统自动检测空投箱子
- 时间追踪：记录和计算刷新时间（默认间隔1100秒）
- 位面追踪：检测和显示当前位面ID
- 团队通知：支持团队/小队通知功能
- 多语言支持：zhCN/zhTW/enUS/ruRU

**版本**：1.1.3-rev1  
**接口版本**：110200, 110205, 110207

---

## 架构设计

### 模块化分层架构

```
核心层 (Core)
  ├─ Core.lua - 事件处理、初始化协调
  │
数据层 (Data)
  ├─ MapConfig.lua - 地图配置（7个地图，间隔1100秒）
  └─ Data.lua - 数据管理、时间计算、持久化
  │
功能层 (Modules)
  ├─ Timer.lua - 检测循环协调（每1秒）
  ├─ IconDetector.lua - 图标检测（提取 objectGUID、SpawnUID 和位面ID）
  ├─ MapTracker.lua - 地图匹配（支持父地图）
  ├─ TeamMessageReader.lua - 团队消息读取和处理
  ├─ Notification.lua - 通知系统
  ├─ Phase.lua - 位面检测（实时检测，不存储）
  ├─ Area.lua - 区域有效性检测
  └─ Commands.lua - 命令处理
  │
  ⚠️ 已移除：
  │   ├─ DetectionState.lua（状态机机制已移除，改为2秒确认机制）
  │   └─ NotificationCooldown.lua（通知冷却期机制已移除）
  │
UI层 (UI)
  ├─ MainPanel.lua - 主面板（每秒更新）
  ├─ FloatingButton.lua - 浮动按钮
  └─ Info.lua - 帮助信息
  │
工具层 (Utils)
  ├─ Logger.lua - 统一日志系统（限流支持）
  ├─ Localization.lua - 本地化管理
  └─ Utils.lua - 通用工具函数
```

### 模块通信机制

- **BuildEnv 系统**：所有模块通过 `BuildEnv(name)` 创建和访问
- **延迟加载**：模块在首次访问时创建
- **全局访问**：所有模块可访问其他模块，但需注意依赖顺序

### 文件加载顺序（Load.xml）

1. 基础工具（Utils/Utils.lua, Utils/Logger.lua）
2. 本地化系统（Utils/Localization.lua, Locales/*.lua）
3. 数据管理（Data/MapConfig.lua, Data/Data.lua）
4. 功能模块（按依赖顺序）
5. UI模块（Core/Core.lua, UI/*.lua）

---

## 核心运行逻辑

### 初始化流程

**PLAYER_LOGIN 事件触发**：
1. 初始化 SavedVariables（CRATETRACKERZK_DB, CRATETRACKERZK_UI_DB）
2. **关键**：清除所有内存检测状态（防止跨角色污染）
   - TimerManager.detectionState = {}（清除2秒确认期的临时状态）
   - MapTracker:Initialize()
   - Phase:Reset()
   - Area 状态重置
3. 初始化各模块（Localization, Data, Notification, Commands, TeamMessageReader）
4. 启动检测系统（TimerManager:StartMapIconDetection(1)）
5. 创建UI界面
6. 检查区域有效性
7. 启动位面检测定时器（取消延迟，立即启动）
   - 如果区域有效，立即创建10秒间隔的定时器
   - 立即执行一次位面检测

### 检测循环（每1秒）

```
TimerManager:DetectMapIcons()
  ├─ 获取当前地图ID (C_Map.GetBestMapForUnit("player"))
  ├─ 匹配目标地图 (MapTracker:GetTargetMapData)
  │   └─ 支持父地图匹配
  ├─ 处理地图变化 (MapTracker:OnMapChanged)
  ├─ 检测图标 (IconDetector:DetectIcon)
  │   ├─ 提取 objectGUID、SpawnUID
  │   └─ 仅依赖名称匹配，不检查位置
  ├─ objectGUID 比对（去重机制）
  │   └─ 如果与 currentAirdropObjectGUID 相同，跳过处理
  ├─ 2秒确认机制（临时状态）
  │   ├─ 首次检测：记录 firstDetectedTime 和 SpawnUID
  │   ├─ 持续检测2秒：确认 SpawnUID 仍然相同
  │   └─ 确认后处理空投事件
  └─ 处理空投事件：
      ├─ 判断处理方式：
      │   ├─ 如果首次检测（未通过团队消息更新）：
      │   │   ├─ 无条件发送通知（不需要30秒限制）
      │   │   ├─ 更新刷新时间：lastRefresh = firstDetectedTime
      │   │   ├─ 从 objectGUID 提取位面ID并存储到 lastRefreshPhase
      │   │   └─ 更新 currentAirdropObjectGUID 和 currentAirdropTimestamp
      │   └─ 如果已通过团队时间共享更新：
      │       ├─ 检查30秒通知限制（基于团队消息更新的时间）
      │       ├─ 发送通知（如果需要）
      │       ├─ 不更新刷新时间（保持团队消息更新的时间）
      │       ├─ 从 objectGUID 提取位面ID并存储到 lastRefreshPhase
      │       └─ 只更新 currentAirdropObjectGUID 和 currentAirdropTimestamp（补齐信息）
      └─ 更新UI显示
```

### 2秒确认机制（非状态机）

**说明**：
- 这不是一个状态机机制，而是一个简单的临时状态记录
- 只要在有效区域，检测就会持续进行，没有暂停机制
- 临时状态仅用于2秒确认期，确认后立即清除

**流程**：
1. 首次检测到图标时，记录临时状态：`firstDetectedTime` 和 `objectGUID`
2. 持续检测，确保图标存在至少2秒
3. 2秒后，重新检测图标，确认：
   - 图标仍然存在
   - objectGUID 仍然相同
4. 如果确认通过，处理空投事件，然后清除临时状态
5. 如果图标消失或 objectGUID 不同，清除临时状态，继续检测

### objectGUID 去重机制

**目的**：识别同一空投事件，防止重复检测和通知

**原理**：
- objectGUID 是完整的游戏对象标识符，每次空投事件生成时都是唯一的
- 同一空投事件的 objectGUID 在整个事件生命周期内保持不变
- 通过比对完整的 objectGUID 可以准确识别是否是同一个空投事件

**比对逻辑**：
1. 检测到图标时，获取完整的 `objectGUID`
2. 与 `mapData.currentAirdropObjectGUID` 比对
3. 如果相同，跳过处理（同一事件）
4. 如果不同或不存在，视为新事件，开始检测流程

### 30秒通知限制

**重要原则**：
- **首次检测（玩家插件自己检测到的空投）**：无条件发送通知，不需要30秒限制
  - 原因：这是实时检测，`timeSinceDetection ≈ 2秒`（2秒确认期），应该立即通知团队
  - 逻辑：首次检测时，插件刚刚检测到空投，应该立即通知，不需要限制
- **已通过团队时间共享更新**：需要30秒限制检查
  - 目的：防止空投事件开始后很久才进入地图的玩家发送通知
  - 机制：基于 `mapData.currentAirdropTimestamp`（团队消息更新的时间戳）
  - 计算：`timeSinceAirdrop = currentTime - currentAirdropTimestamp`
  - 如果 `timeSinceAirdrop <= 30秒`，允许发送通知
  - 如果 `timeSinceAirdrop > 30秒`，不发送通知（防止旧空投通知）

**关键点**：
- 30秒限制仅用于"已通过团队时间共享更新"的情况
- 首次检测时无条件发送通知，这是不可改变的核心逻辑

### 区域有效性检测（Area）

**无效区域**（自动暂停检测）：
- 副本类型：party, raid, pvp, arena, scenario
- 无法获取地图ID
- 当前地图不在追踪列表中（且父地图也不在）

**有效区域**（恢复检测）：
- 不是副本/战场
- 当前地图在追踪列表中（或父地图在列表中）
- **注意**：室内区域不再被视为无效

### 位面检测（Phase）

**存储的位面ID（lastRefreshPhase）**：
- 从空投的 objectGUID 中提取（检测到空投时使用 `IconDetector.ExtractPhaseID(objectGUID)` 提取）
- GUID格式：`Creature-0-[分片ID]-[实例ID]-[zoneUID]-[NPC ID]-[spawnUID]` 或 `GameObject-0-[分片ID]-[实例ID]-[zoneUID]-[GameObject ID]-[spawnUID]`
- 位面ID = `分片ID-实例ID`（第3部分-第4部分）
- 存储到 `lastRefreshPhase`（持久化）

**实时检测的位面ID（currentPhaseID）**：
- Phase 模块独立检测（从NPC的GUID提取位面信息）
- 不存储到 lastRefreshPhase，仅用于UI显示和比较
- 存储到 `currentPhaseID`（内存，不持久化）
- UI显示：显示 Phase 模块检测到的位面ID（currentPhaseID）
- 颜色判断：当 `currentPhaseID`（Phase模块检测）和 `lastRefreshPhase`（从objectGUID提取）不同时，红色显示提醒位面变化

**位面ID缓存机制（phaseCache）**：
- **缓存位置**：存储在全局变量 `_G["Phase"].phaseCache`（内存，不持久化）
- **缓存目的**：即使暂时检测不到位面ID，也能显示缓存的位面ID，提升用户体验
- **缓存更新**：只有当检测到新的位面ID且与缓存不同时，才更新缓存
- **缓存使用**：
  - 如果检测到新的位面ID：与缓存比较，不同则更新缓存
  - 如果检测不到位面ID：使用缓存的位面ID（如果存在）用于UI显示
- **缓存清除**：
  - 退出游戏（PLAYER_LOGOUT）：自动清除所有缓存
  - 切换角色（PLAYER_LOGIN）：自动清除所有缓存
  - 重载插件（/reload）：缓存会被清除（Lua 代码重新执行，这是 WoW 插件的正常行为）

**触发时机**：
- 玩家登录（PLAYER_LOGIN）：如果区域有效，立即启动位面检测定时器（取消延迟）
- 区域变化（ZONE_CHANGED, ZONE_CHANGED_NEW_AREA）：如果区域有效，立即检测（取消延迟）
- 目标改变（PLAYER_TARGET_CHANGED）：如果区域有效，立即检测
- 鼠标悬停NPC（工具提示显示）：如果区域有效，立即检测
- 定时器：每10秒执行一次（在有效区域持续检测）

---

## 数据管理

### 数据结构

**内存数据（Data.maps）**：
```lua
{
  [id] = {
    id = 1,                    -- 内部ID（从1开始）
    mapID = 2248,             -- 游戏地图ID
    interval = 1100,          -- 刷新间隔（秒）
    lastRefreshPhase = "123-456", -- 从空投的 objectGUID 提取的位面ID（持久化）
    lastRefresh = timestamp,  -- 上次刷新时间戳（完整Unix时间戳）
    nextRefresh = timestamp,  -- 下次刷新时间戳（计算得出，不持久化）
    createTime = timestamp,   -- 创建时间
    currentAirdropObjectGUID = "Creature-0-3903-2601-46834-135181-00005467A0",  -- 当前空投事件的完整 objectGUID
    currentAirdropTimestamp = timestamp, -- 当前空投事件的时间戳（完整Unix时间戳）
    currentPhaseID = "123-456"  -- Phase 模块实时检测到的位面ID（不持久化，仅用于UI显示和比较）
  }
}
```

**持久化数据（SavedVariables）**：
- `CRATETRACKERZK_DB`：地图数据（所有角色共享）
- `CRATETRACKERZK_UI_DB`：UI设置（所有角色共享）

**内存状态（不持久化，每次登录清除）**：
- TimerManager.detectionState（2秒确认期的临时状态）
- MapTracker 的地图追踪状态
- Phase 的位面检测状态（lastReportedInstanceID, lastReportedMapPhaseKey）
- Phase.phaseCache（位面ID缓存，以mapID为key，退出游戏或切换角色时清除）
- currentPhaseID（实时检测到的位面ID，仅用于UI显示）

### 时间计算逻辑

```
nextRefresh = lastRefresh + n * interval

其中：
- lastRefresh: 上次刷新时间戳
- interval: 刷新间隔（默认1100秒）
- n: 计算出的刷新次数

n 的计算：
- 如果 lastRefresh < currentTime:
  n = ceil((currentTime - lastRefresh) / interval)
- 如果 lastRefresh >= currentTime:
  向前计算，找到最接近当前时间的未来刷新点
```

### 数据更新流程

**自动检测更新**：
1. 检测到图标 → 提取 objectGUID
2. objectGUID 比对（如果相同，跳过处理）
3. 2秒确认机制（记录 firstDetectedTime 和 objectGUID，持续检测2秒）
4. 确认后：
   - **如果首次检测（未通过团队消息更新）**：
     - **无条件发送通知**（不需要30秒限制，这是不可改变的核心逻辑）
     - Data:SetLastRefresh(mapId, firstDetectedTime)
     - 从 objectGUID 提取位面ID并存储到 lastRefreshPhase（使用 IconDetector.ExtractPhaseID）
     - 更新 currentAirdropObjectGUID 和 currentAirdropTimestamp
   - **如果已通过团队消息更新过时间**：
     - 检查30秒通知限制（基于团队消息更新的时间：currentAirdropTimestamp）
     - 发送通知（如果需要，且未超过30秒）
     - 只更新 currentAirdropObjectGUID 和 lastRefreshPhase（补齐缺失信息）
     - 不更新刷新时间（一个空投事件只允许更新一次时间）
5. Data:SaveMapData(mapId)
6. TimerManager:UpdateUI() → MainPanel:UpdateTable()

**刷新按钮更新**（优化后）：
1. 立即更新内存数据（同步）
2. 立即更新UI显示（同步）
3. 异步保存数据（C_Timer.After(0, ...)）

**手动输入更新**：
1. 解析时间输入（HH:MM:SS 或 HHMMSS）
2. 转换为时间戳
3. TimerManager:StartTimer(mapId, MANUAL_INPUT, timestamp)

---

## 关键设计原则

### 1. 状态隔离原则

**全局数据（SavedVariables）**：
- ✅ 所有角色共享（刷新时间、位面信息）
- ✅ 持久化保存

**内存状态（模块变量）**：
- ✅ 每个角色独立（检测状态、追踪状态）
- ✅ 每次登录时清除（防止跨角色污染）

### 2. 防误触机制

- **2秒持续检测确认**：防止短暂图标闪烁误判（临时状态，确认后清除）
- **objectGUID 比对**：通过比对完整的 objectGUID 识别同一空投事件，防止重复检测和通知
- **30秒通知限制**：仅用于"已通过团队时间共享更新"的情况，防止旧空投通知
- **首次检测无条件通知**：首次检测（玩家插件自己检测到的空投）无条件发送通知，不需要30秒限制（这是不可改变的核心逻辑）
- **单次更新原则**：一个地图的同一个空投事件只允许更新一次时间（要么本地检测，要么团队消息）

### 3. 检测原理

**图标检测**：
- 仅依赖名称匹配（"War Supply Crate" / "战争物资箱"）
- 不检查位置信息（支持子地图场景）
- 使用 `C_VignetteInfo.GetVignettes()` 获取所有图标
- 从 objectGUID 中提取位面ID（第3部分-第4部分），存储到 lastRefreshPhase

**地图匹配**：
- 支持直接地图ID匹配
- 支持父地图匹配（子地图继承父地图配置）

### 4. 通知系统

**自动检测通知**（受 `/ctk team on/off` 控制）：
- 聊天框：始终发送
- 团队中：RAID + RAID_WARNING（如果启用）
- **首次检测**：无条件发送通知，不需要30秒限制（这是不可改变的核心逻辑）
- **已通过团队时间共享更新**：需要30秒限制检查，防止旧空投通知

**手动通知**（不受命令控制）：
- 在队伍中：发送到队伍（PARTY/RAID/INSTANCE_CHAT）
- 不在队伍中：发送到聊天框

**团队消息处理**：
- 不在空投地图的玩家：无条件更新时间为收到消息时的时间戳
- 在空投地图的玩家：跳过处理（由本地检测处理）
- 飞到空投地图后：如果已通过团队消息更新过时间，只补齐 objectGUID 和 lastRefreshPhase 相关数据，不更新时间

### 5. 日志系统

**日志级别**：
- ERROR（红色）
- WARN（橙色）
- INFO（蓝色）
- DEBUG（绿色，需开启调试模式）
- SUCCESS（绿色）

**限流机制**：
- 不同类型消息不同限流间隔
- 限流消息统计（显示被限流的消息数量）
- 调试模式可开关（持久化到 CRATETRACKERZK_UI_DB）

---

## 重要约束和注意事项

### 1. 角色切换问题（已修复）

**问题**：内存检测状态跨角色共享导致检测异常

**解决方案**：
- 每次 `PLAYER_LOGIN` 时清除所有内存检测状态
- 保留全局 SavedVariables 数据（刷新时间共享）

### 2. 地图配置

**当前支持的地图**（Data/MapConfig.lua）：
- 多恩岛 (2248)
- 海妖岛 (2369)
- 卡雷什 (2371)
- 安德麦 (2346)
- 陨圣峪 (2215)
- 喧鸣深窟 (2214)
- 艾基-卡赫特 (2255)

所有地图使用相同刷新间隔：1100秒

### 3. 空投箱子配置

**代码**：`WarSupplyCrate`  
**名称**：通过本地化系统获取（"War Supply Crate" / "战争物资箱"）

### 4. 时间输入格式

支持两种格式：
- `HH:MM:SS`（如：14:30:00）
- `HHMMSS`（如：143000）

### 5. 版本号规范

**正式版（main分支）**：`x.y.z`（如：1.1.3）  
**开发版（dev分支）**：`x.y.z-dev`（如：1.1.3-dev）

---

## 常用命令

- `/ctk` 或 `/ct` - 打开/关闭主面板
- `/ctk help` - 显示帮助信息
- `/ctk clear` - 清除所有数据并重新初始化
- `/ctk team on/off` - 开启/关闭团队通知
- `/ctk debug on/off` - 开启/关闭调试模式

---

## 开发指南

### 添加新地图

1. 在 `Data/MapConfig.lua` 的 `current_maps` 中添加配置
2. 在 `Locales/*.lua` 的 `MapNames` 中添加地图名称翻译
3. 无需修改其他代码

### 添加新语言

1. 创建 `Locales/xxXX.lua` 文件
2. 在 `Load.xml` 中添加加载语句（在 enUS.lua 之前）
3. 实现完整的翻译表（参考 enUS.lua）

### 修改检测逻辑

**关键文件**：
- `Modules/Timer.lua` - 检测循环协调（2秒确认机制）
- `Modules/IconDetector.lua` - 图标检测（提取 objectGUID 和位面ID）
- `Modules/Phase.lua` - 位面检测（独立检测模块，实时检测）
- `Modules/TeamMessageReader.lua` - 团队消息处理

**注意事项**：
- 保持2秒确认机制的完整性
- 注意防误触机制（objectGUID 比对）
- **重要**：首次检测时无条件发送通知，不需要30秒限制（这是不可改变的核心逻辑）
- 考虑跨角色状态隔离
- 单次更新原则：一个空投事件只允许更新一次时间
- 位面检测：存储的位面ID从空投的objectGUID提取，UI显示的位面ID使用Phase模块检测

### 调试技巧

1. 开启调试模式：`/ctk debug on`
2. 查看日志输出（带颜色和模块前缀）
3. 使用限流日志避免刷屏
4. 检查检测状态（TimerManager.detectionState）
5. 检查 objectGUID 比对结果

---

## 关键API使用

### 地图系统
- `C_Map.GetBestMapForUnit("player")` - 获取当前地图ID
- `C_Map.GetMapInfo(mapID)` - 获取地图信息

### 图标检测
- `C_VignetteInfo.GetVignettes()` - 获取所有图标GUID
- `C_VignetteInfo.GetVignetteInfo(guid)` - 获取图标信息

### 定时器
- `C_Timer.NewTicker(interval, callback)` - 创建周期性定时器
- `C_Timer.After(delay, callback)` - 延迟执行

### 位面检测
- `UnitGUID("mouseover")` 或 `UnitGUID("target")` - 获取单位GUID
- 解析GUID：`strsplit("-", guid)` - 提取位面信息

---

## 常见问题

### Q: 为什么检测不到空投？
A: 检查以下几点：
1. 是否在有效区域（非副本/战场）
2. 当前地图是否在追踪列表中
3. 是否是同一个空投事件（objectGUID 比对）
4. 调试模式查看详细日志

### Q: 为什么切换角色后检测异常？
A: 已修复。每次登录时会清除所有内存检测状态，确保每个角色独立。

### Q: 为什么通知没有发送？
A: 检查：
1. 自动通知：是否启用团队通知（`/ctk team on`）
2. 是否确认了空投（需要持续检测2秒）
3. 是否在团队中（自动通知仅在团队中发送）
4. 首次检测时无条件发送通知，不需要30秒限制；已通过团队时间共享更新时才需要30秒限制检查

### Q: 如何清除所有数据？
A: 使用命令 `/ctk clear`，会清除所有刷新时间和位面数据，并重新初始化插件。

---

## 文档索引

详细文档位于 `docs/` 目录：
- `FUNCTIONALITY_AND_LOGIC.md` - 完整功能详解
- `RUNTIME_LOGIC.md` - 运行逻辑详解
- `MODULE_ARCHITECTURE.md` - 模块架构
- `DATA_FLOW.md` - 数据流
- `API_REFERENCE.md` - API参考
- `CHANGELOG.md` - 变更日志

---

## 最近优化记录

### 2024-12-29 - 重大重构：基于 objectGUID 去重机制

**优化内容**：
1. **移除状态机机制**：删除 DetectionState 模块，改为2秒确认机制（临时状态）
2. **基于 objectGUID 去重**：通过比对完整的 objectGUID 识别同一空投事件，防止重复检测和通知
3. **位面检测系统优化**：
   - **取消延迟检测**：在有效区域立即启动位面检测，不再延迟6秒
   - **实时检测**：位面检测定时器每10秒执行一次，在有效区域持续检测
   - **独立检测模块**：Phase 模块独立检测位面ID，不依赖空投的 objectGUID
   - **位面ID存储**：从空投的 objectGUID 提取位面ID并存储到 lastRefreshPhase（持久化）
   - **位面ID缓存机制**：添加 `Phase.phaseCache` 缓存机制，即使暂时检测不到位面ID也能显示缓存的位面ID，只有当位面发生变化时才更新缓存
   - **UI显示**：显示 Phase 模块检测到的位面ID（currentPhaseID），如果检测不到则使用缓存的位面ID
   - **颜色判断**：当 currentPhaseID（Phase模块检测）和 lastRefreshPhase（从objectGUID提取）不同时，红色显示提醒位面变化
4. **移除所有冷却机制**：
   - 移除 NotificationCooldown 模块
   - 移除 PROCESSED 状态和3分钟冷却期
   - 改为基于时间戳的限制（30秒通知限制）
5. **单次更新原则**：一个地图的同一个空投事件只允许更新一次时间（要么本地检测，要么团队消息）
6. **团队消息处理优化**：
   - 不在空投地图的玩家：无条件更新时间为收到消息时的时间戳
   - 飞到空投地图后：如果已通过团队消息更新过时间，只补齐 objectGUID 和 lastRefreshPhase 相关数据，不更新时间

**修改的文件**：
- `Modules/Timer.lua` - 实现2秒确认机制和 objectGUID 比对，从 objectGUID 提取位面ID并存储
- `Modules/IconDetector.lua` - 添加位面ID提取函数（ExtractPhaseID）
- `Modules/TeamMessageReader.lua` - 移除冷却机制，优化团队消息处理
- `Modules/Phase.lua` - 独立位面检测模块，实时检测位面ID（不存储到 lastRefreshPhase），支持位面ID缓存机制
- `Core/Core.lua` - 取消位面检测延迟，立即启动检测，添加 PLAYER_LOGOUT 事件处理清除位面ID缓存
- `Data/Data.lua` - 添加 lastRefreshPhase 字段存储位面ID
- `UI/MainPanel.lua` - 更新位面ID显示逻辑，使用 Phase 模块检测的位面ID显示，比较存储和实时检测的位面ID
- `Modules/DetectionState.lua` - **已删除**（不再使用的模块）
- `Modules/NotificationCooldown.lua` - **已删除**（不再使用的模块）

**优化效果**：
- ✅ 代码更简洁：移除了状态机和冷却机制
- ✅ 逻辑更清晰：基于 objectGUID 去重，单次更新原则
- ✅ 性能更好：减少了状态管理开销，位面检测实时响应
- ✅ 功能完整：2秒确认机制防止误报，30秒通知限制防止重复通知
- ✅ 位面检测优化：取消延迟，实时检测，独立模块，UI显示更准确，支持位面ID缓存机制

---

**最后更新**：2024-12-29（位面ID缓存机制）  
**维护者**：capzk

