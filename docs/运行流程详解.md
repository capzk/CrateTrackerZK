# CrateTrackerZK 运行流程详解

## 目录

1. [插件初始化流程](#插件初始化流程)
2. [空投检测流程](#空投检测流程)
3. [团队消息处理流程](#团队消息处理流程)
4. [位面检测流程](#位面检测流程)
5. [数据处理与保存流程](#数据处理与保存流程)
6. [UI更新流程](#ui更新流程)
7. [手动操作流程](#手动操作流程)

---

## 插件初始化流程

### 文件加载顺序

插件按照 `Load.xml` 定义的顺序加载：

```
1. 基础工具层
   ├─ Utils/Utils.lua（通用工具函数）
   └─ Utils/Logger.lua（日志系统）

2. 本地化系统
   ├─ Utils/Localization.lua（本地化管理器）
   ├─ Locales/Locales.lua（语言注册）
   └─ Locales/*.lua（各语言翻译文件）

3. 数据管理层
   ├─ Data/MapConfig.lua（地图配置）
   └─ Data/Data.lua（数据管理器）

4. 功能模块层
   ├─ Modules/Notification.lua（通知系统）
   ├─ Modules/TeamMessageReader.lua（团队消息读取）
   ├─ Modules/Commands.lua（命令处理）
   ├─ Modules/IconDetector.lua（图标检测）
   ├─ Modules/MapTracker.lua（地图追踪）
   ├─ Modules/Timer.lua（定时器管理器）
   ├─ Modules/Area.lua（区域检测）
   └─ Modules/Phase.lua（位面检测）

5. UI层
   ├─ UI/Info.lua（帮助信息）
   ├─ Core/Core.lua（核心初始化）
   ├─ UI/FloatingButton.lua（浮动按钮）
   └─ UI/MainPanel.lua（主面板）
```

### PLAYER_LOGIN 事件触发初始化

当玩家登录时，触发 `PLAYER_LOGIN` 事件，执行以下初始化流程：

#### 1. 初始化 SavedVariables

```
检查并初始化持久化存储：
├─ CRATETRACKERZK_UI_DB（UI设置，所有角色共享）
└─ CRATETRACKERZK_DB（地图数据，所有角色共享）
```

#### 2. 清除所有内存检测状态

```
防止跨角色污染，清除所有非持久化状态：
├─ TimerManager.detectionState = {}（清除2秒确认期的临时状态）
├─ MapTracker:Initialize()（重置地图追踪状态）
├─ Phase:Reset()（重置位面检测状态和位面ID缓存）
│   ├─ Phase.lastReportedInstanceID = nil
│   ├─ Phase.lastReportedMapPhaseKey = nil
│   └─ Phase.phaseCache = {}（清除位面ID缓存）
├─ Area.lastAreaValidState = nil, Area.detectionPaused = false（区域状态重置）
├─ 所有地图数据的 currentPhaseID = nil（清除实时检测到的位面ID）
├─ CrateTrackerZK.phaseTimerPaused = false, phaseResumePending = false（定时器状态重置）
├─ MainPanel.lastNotifyClickTime = {}（清除通知按钮点击时间）
└─ Logger:ClearMessageCache()（清除日志缓存）
```

**注意**：SavedVariables 数据（刷新时间、位面信息等）保留，只有内存状态被清除。

#### 3. 初始化各模块

```
按顺序初始化各功能模块：
├─ Localization:Initialize()（本地化系统）
├─ Data:Initialize()（数据管理器）
│   ├─ 从 SavedVariables 加载地图数据
│   ├─ 验证和清理时间戳
│   ├─ 计算下次刷新时间
│   └─ 处理数据迁移（兼容旧版本）
├─ Notification:Initialize()（通知系统）
├─ Commands:Initialize()（命令处理）
└─ TeamMessageReader:Initialize()（团队消息读取）
```

#### 4. 启动检测系统

```
启动核心检测循环：
├─ TimerManager:Initialize()（初始化定时器管理器）
├─ TimerManager:StartMapIconDetection(1)（每1秒执行一次检测）
└─ 启动位面检测定时器（取消延迟，立即启动）
    ├─ 创建10秒间隔的定时器（C_Timer.NewTicker(10, ...)）
    └─ 立即执行一次位面检测（Phase:UpdatePhaseInfo()）
```
```

#### 5. 创建UI界面

```
创建用户界面：
├─ MainPanel:CreateMainFrame()（创建主面板）
└─ CrateTrackerZK:CreateFloatingButton()（创建浮动按钮）
```

#### 6. 检查区域有效性

```
检查当前区域是否有效：
└─ Area:CheckAndUpdateAreaValid()
    ├─ 检查是否在副本/战场（无效区域）
    ├─ 检查当前地图是否在追踪列表中
    └─ 如果有效，启动位面检测定时器（取消延迟，立即启动）
        ├─ 创建10秒间隔的定时器（C_Timer.NewTicker(10, ...)）
        └─ 立即执行一次位面检测（Phase:UpdatePhaseInfo()）
```

---

## 空投检测流程

### 核心检测循环（每1秒执行）

```
TimerManager:DetectMapIcons()（每1秒执行）
│
├─ 1. 获取当前地图ID
│   └─ currentMapID = C_Map.GetBestMapForUnit("player")
│
├─ 2. 匹配目标地图数据
│   └─ targetMapData = MapTracker:GetTargetMapData(currentMapID)
│       ├─ 首先尝试直接匹配当前地图ID
│       └─ 如果未匹配，尝试匹配父地图ID（支持子地图场景）
│
├─ 3. 处理地图变化
│   └─ MapTracker:OnMapChanged(currentMapID, targetMapData, currentTime)
│       └─ 记录地图切换时间（用于调试）
│
├─ 4. 检测图标
│   └─ iconResult = IconDetector:DetectIcon(currentMapID)
│       ├─ 获取所有Vignette图标：C_VignetteInfo.GetVignettes()
│       ├─ 遍历查找空投箱子（通过名称匹配）
│       ├─ 优先检测飞机图标（vignetteID = 3689）
│       ├─ 提取 objectGUID（完整的游戏对象标识符）
│       └─ 返回检测结果：{detected, objectGUID, vignetteGUID, vignetteID}
│           └─ 位面ID从 objectGUID 中提取（使用 IconDetector.ExtractPhaseID(objectGUID)），存储到 lastRefreshPhase
│
└─ 5. 处理检测结果
    │
    ├─ 情况A：未检测到图标
    │   └─ 如果存在2秒确认期的临时状态，清除临时状态
    │       └─ 返回 false（继续检测）
    │
    ├─ 情况B：检测到图标
    │   │
    │   ├─ 5.1 检查是否是已知事件（objectGUID比对）
    │   │   └─ if targetMapData.currentAirdropObjectGUID == objectGUID
    │   │       └─ 返回 true（跳过处理，同一事件）
    │   │
    │   ├─ 5.2 重载后比对（防止重载后重复检测）
    │   │   └─ TeamMessageReader:CheckHistoricalSpawnUID(mapId, spawnUID)
    │   │       └─ 如果相同，返回 true（跳过处理）
    │   │
    │   ├─ 5.3 首次检测或新事件
    │   │   └─ if not detectionState[mapId]（临时状态，用于2秒确认）
    │   │       ├─ 记录首次检测时间：firstDetectedTime = currentTime
    │   │       ├─ 记录 SpawnUID：detectedSpawnUID = spawnUID
    │   │       └─ 返回 true（等待2秒确认）
    │   │
    │   ├─ 5.4 检查 SpawnUID 是否变化
    │   │   └─ if detectionState.detectedSpawnUID ~= spawnUID
    │   │       ├─ 检测到新事件，重新开始检测
    │   │       └─ 更新临时状态（重置首次检测时间）
    │   │
    │   └─ 5.5 2秒确认机制
    │       └─ if (currentTime - firstDetectedTime) >= 2秒
    │           ├─ 重新检测图标（双重验证）
    │           ├─ 确认 SpawnUID 仍然相同
            │           ├─ 检查是否已通过团队消息更新过时间
            │           ├─ 判断通知发送逻辑：
            │           │   ├─ 如果首次检测：无条件发送通知（不需要30秒限制）
            │           │   └─ 如果已通过团队时间共享更新：检查30秒通知限制后发送
            │           ├─ 发送团队消息通知（如果需要）
    │           ├─ 判断处理方式：
    │           │   ├─ 如果已通过团队消息更新过时间（无论是否超过30秒）：
            │           │   │   ├─ 不更新刷新时间（保持团队消息更新的时间，一个空投事件只允许更新一次）
            │           │   │   ├─ 只补齐缺失的空投信息（currentAirdropObjectGUID 和 lastRefreshPhase）
            │           │   │   └─ 如果超过30秒：不发送通知；如果未超过30秒：发送通知
            │           │   └─ 否则（首次检测，未通过团队消息更新）：
            │           │       ├─ 更新刷新时间（使用首次检测时间戳：firstDetectedTime）
            │           │       ├─ 更新 currentAirdropObjectGUID 和 currentAirdropTimestamp（时间戳）
            │           │       └─ 从 objectGUID 提取位面ID并存储到 lastRefreshPhase
    │           └─ 清除临时状态（2秒确认期结束）
```

### 2秒确认机制详解

**目的**：防止短暂图标闪烁导致的误报

**说明**：
- 这不是一个状态机机制，而是一个简单的临时状态记录
- 只要在有效区域，检测就会持续进行，没有暂停机制
- 临时状态仅用于2秒确认期，确认后立即清除

**流程**：
1. 首次检测到图标时，记录临时状态：`firstDetectedTime` 和 `objectGUID`
2. 持续检测，确保图标存在至少2秒
3. 2秒后，重新检测图标，确认：
   - 图标仍然存在
   - objectGUID 仍然相同
4. 如果确认通过，处理空投事件，然后清除临时状态
5. 如果图标消失或 objectGUID 不同，清除临时状态，继续检测

### objectGUID 去重机制

**目的**：识别同一空投事件，防止重复检测和通知

**原理**：
- objectGUID 是完整的游戏对象标识符，每次空投事件生成时都是唯一的
- 同一空投事件的 objectGUID 在整个事件生命周期内保持不变
- 通过比对完整的 objectGUID 可以准确识别是否是同一个空投事件

**比对逻辑**：
1. 检测到图标时，获取完整的 `objectGUID`
2. 与 `mapData.currentAirdropObjectGUID` 比对
3. 如果相同，跳过处理（同一事件）
4. 如果不同或不存在，视为新事件，开始检测流程

**优势**：
- 使用完整的 objectGUID 比对，比仅使用 SpawnUID 更准确
- 从 objectGUID 中提取位面ID并存储到 lastRefreshPhase（持久化）

### 30秒通知限制

**重要原则**：
- **首次检测（玩家插件自己检测到的空投）**：无条件发送通知，不需要30秒限制
  - 原因：这是实时检测，`timeSinceDetection ≈ 2秒`（2秒确认期），应该立即通知团队
  - 逻辑：首次检测时，插件刚刚检测到空投，应该立即通知，不需要限制
  - **这是不可改变的核心逻辑**
- **已通过团队时间共享更新**：需要30秒限制检查
  - 目的：防止空投事件开始后很久才进入地图的玩家发送通知
  - 机制：基于 `mapData.currentAirdropTimestamp`（团队消息更新的时间戳）
  - 计算：`timeSinceAirdrop = currentTime - currentAirdropTimestamp`
  - 如果 `timeSinceAirdrop <= 30秒`，允许发送通知
  - 如果 `timeSinceAirdrop > 30秒`，不发送通知（防止旧空投通知）

**关键点**：
- 30秒限制仅用于"已通过团队时间共享更新"的情况
- 首次检测时无条件发送通知，这是不可改变的核心逻辑

**场景**：
- **在空投地图的玩家首次检测**：
  - **无条件发送通知**（不需要30秒限制，这是不可改变的核心逻辑）
  - 更新刷新时间：lastRefresh = firstDetectedTime
  - 更新所有空投信息
- **不在空投地图的玩家飞到空投地图后**：
  - 如果已经通过团队消息更新过时间：
    - 检查30秒通知限制（基于团队消息更新的时间：currentAirdropTimestamp）
    - 如果未超过30秒：发送通知
    - 如果超过30秒：不发送通知（防止旧空投通知）
    - 不更新刷新时间（保持团队消息更新的时间，一个空投事件只允许更新一次时间）
    - 只补齐缺失的空投信息（currentAirdropObjectGUID 和 lastRefreshPhase）
  - 如果未通过团队消息更新过时间（首次检测）：
    - **无条件发送通知**（不需要30秒限制，这是不可改变的核心逻辑）
    - 正常处理：更新刷新时间、更新所有空投信息
  - 如果未通过团队消息更新过时间（首次检测）：
    - 正常处理（发送通知、更新刷新时间、更新所有空投信息）

**重要原则**：
- **一个地图的同一个空投事件只允许更新一次时间**
- **要么当前地图自动检测更新，要么通过团队消息更新，只允许更新一次**
- **一旦确认当前空投事件空投时间就不再更改**

---

## 团队消息处理流程

### 消息监听

```
监听团队聊天消息：
├─ 监听频道：RAID, RAID_WARNING, PARTY, INSTANCE_CHAT
└─ 触发事件：CHAT_MSG_RAID, CHAT_MSG_RAID_WARNING, CHAT_MSG_PARTY, CHAT_MSG_INSTANCE_CHAT
```

### 消息处理流程

```
TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
│
├─ 1. 验证消息格式
│   ├─ 检查消息是否为空
│   ├─ 检查聊天类型是否有效
│   └─ 解析消息，提取地图名称
│       └─ 匹配插件自动发送的消息格式（AirdropDetected）
│
├─ 2. 跳过自己发送的消息
│   └─ if sender == playerName
│       └─ 返回 false（不处理自己的消息）
│
├─ 3. 获取地图ID
│   └─ mapId = GetMapIdByName(mapName)
│
├─ 4. 检查是否是同一事件（objectGUID比对）
│   └─ if mapData.currentAirdropObjectGUID == objectGUID（从消息中提取）
│       └─ 返回 false（同一事件，跳过处理）
│
├─ 5. 判断玩家是否在空投地图
│   └─ isOnMap = (currentMapID == mapData.mapID)
│
    └─ 6. 根据是否在地图处理
    │
    ├─ 情况A：不在空投地图
    │   ├─ 获取收到消息时的时间戳：currentTime = time()
    │   ├─ **无条件更新**：无论自己插件当前时间是多少，统统更新
    │   ├─ 更新 lastRefresh = currentTime（时间戳，以团队消息时间为准）
    │   ├─ 更新 currentAirdropTimestamp = currentTime（时间戳）
    │   ├─ **注意**：currentAirdropObjectGUID 暂时不更新（等待飞到空投地图后补齐）
    │   ├─ 保存数据到 SavedVariables
    │   └─ 更新UI显示
    │   └─ **说明**：自己的时间不再有效，以空投消息时间为准
    │
    └─ 情况B：在空投地图
        └─ 跳过处理（由本地检测系统处理）
            └─ 本地检测会使用首次检测时间（firstDetectedTime）作为时间戳
            └─ 本地检测会比对 objectGUID，避免重复更新
```

### 团队消息更新时间逻辑

**核心原则**：
1. **在空投地图的玩家**：
   - 插件自动检测到空投并二次确认后，使用**首次检测时间戳**（`firstDetectedTime`）更新 `lastRefresh` 和 `currentAirdropTimestamp`
   - 同时发送团队消息通知其他玩家
   - **不需要通过团队消息来更新时间**，因为本地检测已经更新

2. **不在空投地图的玩家**：
   - 收到团队消息后，**无条件更新**时间为收到消息时的时间戳（`currentTime = time()`）
   - **无论自己插件当前时间是多少，统统更新**
   - **自己的时间不再有效，以空投消息时间为准**
   - 更新 `lastRefresh = currentTime`（时间戳）
   - 更新 `currentAirdropTimestamp = currentTime`（时间戳）
   - **注意**：`currentAirdropSpawnUID` 暂时不更新（等待飞到空投地图后通过自动检测补齐）
   - **所有时间都以时间戳方式处理**（完整Unix时间戳）

3. **不在空投地图的玩家飞到空投地图后**：
   - 插件自动检测到空投事件
   - **如果已经通过团队消息更新过时间**（无论是否超过30秒）：
     - **不发送通知**（如果超过30秒）或**发送通知**（如果未超过30秒）
     - **不更新刷新时间**（保持团队消息更新的时间，一个空投事件只允许更新一次时间）
     - **只补齐缺失的空投信息**：更新 `currentAirdropObjectGUID`（用于判断是否是同一个空投事件）
   - **如果未通过团队消息更新过时间**（首次检测）：
     - 正常处理：发送通知、更新刷新时间、更新所有空投信息

4. **如果玩家一直没有飞过去空投地图**：
   - 只更新了空投时间（`lastRefresh` 和 `currentAirdropTimestamp`）
   - `currentAirdropObjectGUID` 保持旧值或 `nil`，等待下次更新
   - 不影响功能，因为时间已经更新，只是缺少 objectGUID 相关数据用于去重判断

**SpawnUID比对**：
- 如果消息中的 SpawnUID 与本地记录的相同
- 跳过处理（同一事件，避免重复更新）

---

## 位面检测流程

### 触发时机

```
位面检测在以下情况触发：
├─ PLAYER_LOGIN（玩家登录）
│   └─ 如果区域有效，立即启动位面检测定时器（取消延迟）
│       ├─ 创建10秒间隔的定时器（C_Timer.NewTicker(10, ...)）
│       └─ 立即执行一次位面检测（Phase:UpdatePhaseInfo()）
│
├─ ZONE_CHANGED / ZONE_CHANGED_NEW_AREA（区域变化）
│   └─ 延迟0.1秒后执行
│       └─ 如果区域有效，立即检测位面信息（取消延迟）
│
├─ PLAYER_TARGET_CHANGED（目标改变）
│   └─ 如果区域有效，立即更新位面信息
│
└─ Tooltip显示（鼠标悬停NPC）
    └─ 如果区域有效，立即更新位面信息
```

**关键改进**：
- ✅ **取消延迟检测**：在有效区域立即启动位面检测，不再延迟6秒
- ✅ **实时检测**：位面检测定时器每10秒执行一次，在有效区域持续检测
- ✅ **事件驱动**：区域变化、目标改变、鼠标悬停时立即检测

### 位面检测流程

```
Phase:UpdatePhaseInfo()
│
├─ 1. 检查区域有效性
│   └─ if Area.detectionPaused
│       └─ 返回（区域无效，不检测）
│
├─ 2. 获取当前地图ID
│   └─ currentMapID = Area:GetCurrentMapId()
│
├─ 3. 匹配目标地图数据
│   └─ targetMapData = Data:GetAllMaps() 然后遍历匹配
│
├─ 4. 获取实时位面ID（Phase 模块独立检测）
│   └─ detectedPhaseID = Phase:GetLayerFromNPC()
│       ├─ 尝试从鼠标悬停的NPC获取：UnitGUID("mouseover")
│       ├─ 如果失败，尝试从目标获取：UnitGUID("target")
│       └─ 解析GUID提取位面信息
│           └─ 位面ID = 分片ID + "-" + 实例ID（第3部分-第4部分）
│
└─ 5. 位面ID缓存机制和UI更新
    ├─ 获取缓存的位面ID：cachedPhaseID = Phase.phaseCache[currentMapID]
    ├─ 判断是否需要更新缓存：
    │   ├─ 如果检测到新的位面ID（detectedPhaseID）：
    │   │   ├─ 如果与缓存不同 → 更新缓存 → shouldUpdate = true
    │   │   └─ 如果与缓存相同 → 不更新缓存 → shouldUpdate = false
    │   └─ 如果检测不到位面ID：
    │       └─ 如果缓存存在 → 使用缓存的位面ID
    ├─ 更新 targetMapData.currentPhaseID（用于UI显示）
    ├─ 如果 shouldUpdate = true：
    │   ├─ 首次获取位面ID：发送系统消息 `【地图名】当前位面ID：|cffffff00XX|r`
    │   └─ 位面变化：发送系统消息 `【地图名】当前位面ID已变更为：|cffffff00XX|r`
    └─ 更新UI显示（用于与存储的位面ID比较，不同则红色显示）
```

**关键点**：
- ✅ **独立检测模块**：Phase 模块独立检测位面ID，不依赖空投的 objectGUID
- ✅ **实时检测**：在有效区域每10秒检测一次，事件触发时立即检测
- ✅ **不存储**：检测到的位面ID仅存储到 `currentPhaseID`（内存，不持久化），用于UI显示和比较
- ✅ **位面ID缓存机制**：
  - 缓存位置：`Phase.phaseCache`（全局变量，内存，不持久化）
  - 缓存目的：即使暂时检测不到位面ID，也能显示缓存的位面ID
  - 缓存更新：只有当检测到新的位面ID且与缓存不同时，才更新缓存
  - 缓存清除：退出游戏（PLAYER_LOGOUT）或切换角色（PLAYER_LOGIN）时自动清除

### 位面ID解析

**GUID格式**：
```
Creature-0-[分片ID]-[实例ID]-[zoneUID]-[NPC ID]-[spawnUID]
GameObject-0-[分片ID]-[实例ID]-[zoneUID]-[GameObject ID]-[spawnUID]
```

**位面ID组成**：
- 位面ID = 分片ID + "-" + 实例ID（第3部分-第4部分）
- 例如：`2139-2601`（分片ID=2139，实例ID=2601）

**位面ID来源**：
- **存储的位面ID（lastRefreshPhase）**：从空投的 objectGUID 中提取（检测到空投时使用 `IconDetector.ExtractPhaseID(objectGUID)` 提取并存储）
- **实时检测的位面ID（currentPhaseID）**：从NPC的GUID中提取（通过 Phase 模块独立实时检测，不存储到 lastRefreshPhase）

**关键点**：
- 分片ID是区分位面的关键标识
- 同一位面的玩家分片ID相同
- 不同位面的玩家分片ID不同
- **存储的位面ID**：从空投的 objectGUID 提取，存储到 `lastRefreshPhase`（持久化）
- **实时检测的位面ID**：Phase 模块独立检测，存储到 `currentPhaseID`（内存，不持久化，仅用于UI显示）
- **位面ID缓存**：`Phase.phaseCache`（全局变量，内存，不持久化），以mapID为key，存储每个地图的位面ID
- **UI显示**：显示 Phase 模块检测到的位面ID（currentPhaseID），如果检测不到则使用缓存的位面ID
- **颜色判断**：当 `currentPhaseID`（Phase模块检测）和 `lastRefreshPhase`（从objectGUID提取）不同时，红色显示提醒

---

## 数据处理与保存流程

### 数据结构

**内存数据结构**（`Data.maps`）：
```
mapData = {
    id = 1,                          -- 内部ID（从1开始，不持久化）
    mapID = 2248,                    -- 游戏地图ID（通过key存储，不在此结构中）
    interval = 1100,                 -- 刷新间隔（秒，从配置读取，不持久化）
    lastRefresh = timestamp,         -- 上次刷新时间戳（完整Unix时间戳）
    nextRefresh = timestamp,          -- 下次刷新时间戳（计算得出，不持久化）
    createTime = timestamp,          -- 创建时间
    currentAirdropObjectGUID = "Creature-0-3903-2601-46834-135181-00005467A0",  -- 当前空投事件的完整 objectGUID
    currentAirdropTimestamp = timestamp, -- 当前空投事件的时间戳（完整Unix时间戳）
    lastRefreshPhase = "123-456",     -- 从空投的 objectGUID 提取的位面ID（持久化）
    currentPhaseID = "123-456",       -- Phase 模块实时检测到的位面ID（不持久化，仅用于UI显示和比较）
    -- 注意：倒计时（remaining）不在数据结构中，在UI层通过时间戳计算得出
}
```

**持久化数据结构**（`CRATETRACKERZK_DB.mapData[mapID]`）：
```
savedData = {
    lastRefresh = timestamp,         -- 上次刷新时间戳（完整Unix时间戳）
    createTime = timestamp,          -- 创建时间
    currentAirdropObjectGUID = "Creature-0-3903-2601-46834-135181-00005467A0",  -- 当前空投事件的完整 objectGUID
    currentAirdropTimestamp = timestamp, -- 当前空投事件的时间戳（完整Unix时间戳）
    lastRefreshPhase = "123-456",    -- 从空投的 objectGUID 提取的位面ID（持久化）
}
```

**存储的完整信息**：
- ✅ **地图ID**：通过 `mapID` 作为 key 存储（`CRATETRACKERZK_DB.mapData[mapID]`）
- ✅ **刷新时间戳**：`lastRefresh`（完整Unix时间戳）
- ✅ **空投事件信息**：`currentAirdropObjectGUID`（完整的 objectGUID，用于去重）、`currentAirdropTimestamp`（空投事件时间戳）
- ✅ **位面ID**：`lastRefreshPhase`（从空投的 objectGUID 提取的位面ID，持久化）
- ❌ **倒计时**：不存储，在UI层通过 `nextRefresh` 和当前时间计算得出
- ❌ **实时位面ID**：不存储，仅用于UI显示和比较（`currentPhaseID`，由 Phase 模块实时检测）

**位面信息说明**：
- **存储的位面ID（lastRefreshPhase）**：从空投的 objectGUID 提取（使用 `IconDetector.ExtractPhaseID(objectGUID)`），在检测到空投时提取并存储
- **实时检测的位面ID（currentPhaseID）**：Phase 模块独立检测（从NPC的GUID提取），不存储到 lastRefreshPhase，仅用于UI显示
- **UI显示**：显示 Phase 模块检测到的位面ID（currentPhaseID）
- **颜色判断**：当 `currentPhaseID`（Phase模块检测）和 `lastRefreshPhase`（从objectGUID提取）不同时，红色显示提醒位面变化

### 数据保存流程

```
数据更新触发
│
├─ Data:UpdateMap(mapId, mapData)
│   ├─ 验证允许更新的字段
│   ├─ 更新内存数据（Data.maps[mapId]）
│   └─ 调用 Data:SaveMapData(mapId)
│
└─ Data:SaveMapData(mapId)
    ├─ 确保数据库存在：ensureDB()
    └─ 保存到 SavedVariables
        └─ CRATETRACKERZK_DB.mapData[mapID] = {
            lastRefresh = ...,
            createTime = ...,
            currentAirdropObjectGUID = ...,  -- 完整的 objectGUID（用于去重和位面信息提取）
            currentAirdropTimestamp = ...,
        }
```

### 数据加载流程

```
Data:Initialize()
│
├─ 1. 确保数据库存在
│   └─ ensureDB()
│       ├─ 检查 CRATETRACKERZK_DB 是否存在
│       └─ 检查 CRATETRACKERZK_DB.mapData 是否存在
│
├─ 2. 从配置加载地图列表
│   └─ MAP_CONFIG.current_maps
│
├─ 3. 遍历配置，初始化每个地图
│   ├─ 3.1 检查是否为全新安装
│   │   └─ if type(savedData) ~= "table" then
│   │       └─ 标记为全新安装，初始化空数据
│   │
│   ├─ 3.2 数据完整性检查
│   │   ├─ 验证时间戳（sanitizeTimestamp）
│   │   ├─ 验证位面信息类型（必须是字符串）
│   │   ├─ 验证 SpawnUID 类型（必须是字符串）
│   │   └─ 无效数据清除为 nil
│   │
│   ├─ 3.3 数据迁移（兼容旧版本）
│   │   ├─ 如果旧数据没有新字段，初始化为 nil
│   │   └─ 确保时间戳格式正确（完整Unix时间戳）
│   │
│   ├─ 3.4 初始化地图数据
│   │   ├─ 从 SavedVariables 加载保存的数据
│   │   ├─ 初始化所有字段（包括新字段）
│   │   └─ 兼容旧数据：如果旧数据使用 lastRefreshInstance，自动迁移到 lastRefreshPhase
│   │
│   └─ 3.5 计算下次刷新时间
│       └─ if lastRefresh then
│           └─ UpdateNextRefresh(mapId, mapData)
│
└─ 4. 完成初始化
    ├─ 记录加载的地图数量
    └─ 记录全新安装的地图数量
```

### 全新安装时的初始化

**全新安装判断**：
- 如果 `CRATETRACKERZK_DB.mapData[mapID]` 不存在或不是表类型
- 视为全新安装，初始化空数据结构

**全新安装时的默认值**：
- `lastRefresh = nil`（无时间记录）
- `currentAirdropObjectGUID = nil`（空投信息待检测）
- `currentAirdropTimestamp = nil`
- `createTime = time()`（使用当前时间作为创建时间）
- 位面信息不存储，在UI层从 objectGUID 实时提取

### 数据完整性检查

**时间戳验证**（`sanitizeTimestamp`）：
- 检查是否为数字类型
- 检查是否在合理范围内（0 到 当前时间+1年）
- 无效时间戳返回 `nil`

**位面信息验证**：
- `lastRefreshPhase` 必须是字符串类型
- 无效数据清除为 `nil`
**objectGUID验证**：
- `currentAirdropObjectGUID` 必须是字符串类型
- 无效数据清除为 `nil`

**数据迁移**：
- 自动处理旧版本数据格式
- 如果旧数据没有新字段，初始化为 `nil`
- 确保时间戳格式正确（完整Unix时间戳）

### 时间计算逻辑

**下次刷新时间计算**：
```
nextRefresh = lastRefresh + n * interval

其中：
- lastRefresh: 上次刷新时间戳
- interval: 刷新间隔（默认1100秒）
- n: 计算出的刷新次数

n 的计算：
- 如果 lastRefresh < currentTime:
  n = ceil((currentTime - lastRefresh) / interval)
- 如果 lastRefresh >= currentTime:
  向前计算，找到最接近当前时间的未来刷新点
```

**时间格式化**：
- **存储**：完整Unix时间戳（`time()` 返回的值）
- **UI显示**：只显示时分秒（`HH:MM:SS`）
- **用户输入**：作为过去时间处理（如果输入时间在未来，视为前一天的时间）

---

## UI更新流程

### 主面板更新（每1秒）

```
MainPanel:UpdateTable()
│
├─ 1. 准备表格数据（PrepareTableData）
│   ├─ 获取当前时间：currentTime = time()
│   ├─ 遍历所有地图数据
│   ├─ 检查并更新下次刷新时间（如果已过期）
│   └─ **计算倒计时**：remaining = Data:CalculateRemainingTime(nextRefresh)
│       └─ remaining = nextRefresh - currentTime（在UI层计算，不存储）
│
├─ 2. 应用排序（如果启用）
│   └─ 按剩余时间或上次刷新时间排序
│
└─ 3. 更新表格显示
    ├─ 遍历地图数据
    ├─ 判断是否为空投中：isAirdrop = (currentTime - currentAirdropTimestamp < interval)
    ├─ 格式化时间显示：lastRefreshText = FormatTimeForDisplay(lastRefresh)
    ├─ 显示倒计时：remainingText = FormatTime(remaining, true)
    ├─ 应用颜色（位面ID颜色、倒计时颜色）
    └─ 更新表格行显示
```

**倒计时计算说明**：
- **不存储倒计时**：倒计时（`remaining`）不在数据结构中存储
- **UI层计算**：在 `PrepareTableData()` 中通过 `Data:CalculateRemainingTime(nextRefresh)` 计算
- **实时更新**：每次UI更新时重新计算，确保显示准确
- **计算公式**：`remaining = nextRefresh - currentTime`（如果 `nextRefresh` 存在且大于当前时间）

### 时间显示格式

**上次刷新时间**：
- 格式：`HH:MM:SS`（例如：`14:30:00`）
- 如果无记录：显示 `--:--`

**下次刷新时间**：
- 格式：`HH:MM:SS`（例如：`15:48:20`）
- 如果无记录：显示 `--:--`

**剩余时间**：
- 格式：`MM:SS`（例如：`18:20`）
- 如果已过期：显示负数或特殊标记

---

## 手动操作流程

### 手动输入时间

```
用户点击"上次刷新"列
│
├─ 1. 弹出输入框
│   └─ StaticPopup_Show('CRATETRACKERZK_EDIT_LASTREFRESH')
│
├─ 2. 用户输入时间
│   └─ 格式：HH:MM:SS 或 HHMMSS
│
├─ 3. 解析时间输入
│   └─ Utils.ParseTimeInput(input)
│       ├─ 解析格式1: HH:MM:SS
│       └─ 解析格式2: HHMMSS
│
├─ 4. 转换为时间戳
│   └─ Data:ParseUserInputTime(hh, mm, ss)
│       ├─ 创建日期表（当前日期，用户输入的时间）
│       ├─ 如果时间在未来，视为前一天的时间
│       └─ 转换为Unix时间戳
│
└─ 5. 更新计时器
    └─ TimerManager:StartTimer(mapId, MANUAL_INPUT, timestamp)
        ├─ 更新 lastRefresh
        ├─ 计算 nextRefresh
        ├─ 保存数据
        └─ 更新UI显示
```

### 刷新按钮

```
用户点击"刷新"按钮
│
├─ 1. 获取当前时间戳
│   └─ currentTime = time()
│
├─ 2. 立即更新内存数据
│   ├─ mapData.lastRefresh = currentTime
│   └─ Data:UpdateNextRefresh(mapId)
│
├─ 3. 立即更新UI显示
│   └─ MainPanel:UpdateTable()
│
└─ 4. 异步保存数据
    └─ C_Timer.After(0, function()
        └─ Data:SaveMapData(mapId)
    )
```

### 清除命令

```
用户执行 /ctk clear
│
├─ 1. 停止所有定时器
│   ├─ TimerManager:StopMapIconDetection()
│   ├─ CrateTrackerZK.phaseTimerTicker:Cancel()
│   └─ MainPanel.updateTimer:Cancel()
│
├─ 2. 隐藏并清除UI框架
│   ├─ CrateTrackerZKFrame:Hide() 并设为 nil
│   └─ CrateTrackerZKFloatingButton:Hide() 并设为 nil
│
├─ 3. 清除所有持久化数据
│   ├─ CRATETRACKERZK_DB.mapData（所有地图数据）
│   └─ CRATETRACKERZK_UI_DB（所有UI设置）
│
├─ 4. 清除所有内存状态
│   ├─ Data.maps = {}
│   ├─ TimerManager.detectionState = {}
│   ├─ TimerManager.lastStatusReportTime = 0
│   ├─ MapTracker:Initialize()（重置所有地图追踪状态）
│   ├─ Phase:Reset()（重置位面检测状态）
│   ├─ Area.lastAreaValidState = nil, Area.detectionPaused = false
│   ├─ Notification.isInitialized = false
│   ├─ TeamMessageReader.isInitialized = false
│   │   ├─ TeamMessageReader.messagePatterns = {}
│   │   └─ TeamMessageReader.chatFrame（取消注册事件并清除）
│   ├─ MainPanel.lastNotifyClickTime = {}
│   ├─ CrateTrackerZK.phaseTimerPaused = false
│   ├─ CrateTrackerZK.phaseResumePending = false
│   └─ Logger:ClearMessageCache()
│
├─ 5. 清除所有地图数据中的内存状态
│   └─ 遍历 Data.maps，清除所有 currentPhaseID
│
└─ 6. 重新初始化插件
    └─ CrateTrackerZK:Reinitialize()
        └─ 调用 OnLogin() 重新初始化所有模块
```

---

## 关键机制总结

### 检测机制

1. **持续检测**：只要在有效区域（非副本/战场），检测就会持续进行，没有暂停机制
2. **2秒确认期**：首次检测到图标后，需要持续检测2秒才确认（使用临时状态记录，确认后清除）
3. **SpawnUID比对**：通过比对 SpawnUID 识别同一空投事件，防止重复检测
4. **30秒通知限制**：仅用于"已通过团队时间共享更新"的情况；首次检测时无条件发送通知（这是不可改变的核心逻辑）

### 防误报机制

1. **2秒确认期**：防止短暂图标闪烁导致的误报
2. **SpawnUID比对**：防止同一空投事件重复检测和通知
3. **30秒通知限制**：仅用于"已通过团队时间共享更新"的情况，防止旧空投通知；首次检测时无条件发送通知（这是不可改变的核心逻辑）

### 数据一致性

1. **内存数据**：每次登录时从 SavedVariables 加载
2. **持久化数据**：每次更新后立即保存到 SavedVariables
3. **数据迁移**：自动处理旧版本数据格式

### 性能优化

1. **检测频率**：每1秒检测一次（平衡性能和响应速度）
2. **UI更新频率**：每1秒更新一次（保持显示实时性）
3. **位面检测**：事件驱动，避免频繁轮询
4. **位面ID缓存**：缓存机制提升用户体验，即使暂时检测不到位面ID也能显示缓存的位面ID

---

**最后更新**：2024-12-29  
**维护者**：capzk

---

## 最新更新（2024-12-29）

### 位面检测系统优化
- **取消延迟检测**：在有效区域立即启动位面检测，不再延迟6秒
- **实时检测**：位面检测定时器每10秒执行一次，在有效区域持续检测
- **独立检测模块**：Phase 模块独立检测位面ID，不依赖空投的 objectGUID
- **位面ID存储**：从空投的 objectGUID 提取位面ID并存储到 lastRefreshPhase（持久化）
- **UI显示**：显示 Phase 模块检测到的位面ID（currentPhaseID）
- **颜色判断**：当 currentPhaseID（Phase模块检测）和 lastRefreshPhase（从objectGUID提取）不同时，红色显示提醒位面变化
- **系统消息提醒**：
  - 首次获取到位面ID时发送系统消息："【地图名】当前位面ID：|cffffff00XX|r"
  - 位面发生变化时发送系统消息："【地图名】当前位面ID已变更为：|cffffff00XX|r"
  - 所有消息已本地化（zhCN/zhTW/enUS/ruRU）

### 无效空投提示简化
- 统一为一条系统消息："【地图名】 检测到无效空投事件，空投飞机存在时间过短，判定为无效事件。"
- 移除详细原因说明（图标消失时间、SpawnUID变化等）
- 只发送系统消息，不发送团队通知

### clear命令数据清除完善
- 清除所有定时器、UI框架、内存状态
- 确保完全重新初始化插件

### 全新安装和跨角色状态清理
- 确保全新安装时正确初始化
- 防止跨角色状态污染

