# 团队消息读取更新机制详解

## 文档概述

本文档详细说明 CrateTrackerZK 插件中新增的团队消息读取功能，包括如何读取团队消息、自动更新刷新时间、防止重复读取和更新的完整机制。

**版本**: 1.1.4.20251229_beta  
**最后更新**: 2025-12-29

---

## 一、功能概述

### 1.1 核心功能

团队消息读取功能允许插件监听团队/小队聊天中的空投消息，自动更新对应地图的刷新时间，无论玩家是否在该地图上。

**主要特性**:
- 自动识别插件发送的空投消息（通过消息格式匹配）
- 支持多语言消息格式识别
- 自动更新刷新时间（使用消息发送时间）
- 防止重复更新（时间窗口检查、自己发送的消息检查、PROCESSED状态检查）
- 防止重复通知（30秒冷却期）

### 1.2 使用场景

1. **跨地图更新**: 玩家在A地图，收到B地图的空投消息，自动更新B地图的刷新时间
2. **延迟到达**: 玩家在空投消息发送后1分钟才到达地图，此时空投还在进行，不会再次报告，但刷新时间会更新
3. **多用户协作**: 团队中多个用户插件发送消息，自动同步刷新时间

---

## 二、模块架构

### 2.1 核心模块

**TeamMessageReader** (`Modules/TeamMessageReader.lua`): 团队消息读取器

**主要组件**:
- `messagePatterns`: 存储各语言的消息匹配模式
- `lastTeamMessageTime`: 记录每个地图最后收到团队消息的时间
- `MESSAGE_COOLDOWN`: 30秒冷却期常量

### 2.2 依赖模块

- **Data**: 数据管理器，用于更新刷新时间
- **DetectionState**: 状态机管理器，用于检查PROCESSED状态
- **LocaleManager**: 本地化管理器，用于获取多语言消息格式
- **Logger**: 日志系统，用于输出调试信息

---

## 三、完整执行流程

### 3.1 初始化流程

**触发时机**: `PLAYER_LOGIN` 事件或首次调用 `ProcessTeamMessage`

**执行步骤**:

```
1. TeamMessageReader:Initialize()
   ├─ 清除所有内存状态（防止跨角色污染）
   │   └─ lastTeamMessageTime = {}
   │
   ├─ 初始化消息模式
   │   └─ InitializeMessagePatterns()
   │       ├─ 从 LocaleManager 获取所有已注册的语言
   │       ├─ 遍历所有语言，提取 AirdropDetected 格式
   │       ├─ 去重（避免重复的消息格式）
   │       └─ 为每个消息格式创建匹配模式
   │           ├─ 转义特殊字符
   │           └─ 将 %s 替换为 (.+) 来匹配地图名称
   │
   └─ 注册聊天消息监听
       └─ 创建聊天框架并注册事件
           ├─ CHAT_MSG_RAID
           ├─ CHAT_MSG_RAID_WARNING
           ├─ CHAT_MSG_PARTY
           └─ CHAT_MSG_INSTANCE_CHAT
```

**关键代码位置**: `Modules/TeamMessageReader.lua:Initialize()` (第372-416行)

---

### 3.2 消息监听流程

**触发时机**: 收到团队/小队聊天消息

**执行步骤**:

```
1. 聊天事件触发
   └─ chatFrame:OnEvent(event, ...)
       ├─ 提取消息和发送者
       │   ├─ message = select(1, ...)
       │   └─ sender = select(2, ...)
       │
       └─ 调用处理函数
           └─ TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
```

**关键代码位置**: `Modules/TeamMessageReader.lua:Initialize()` (第394-404行)

---

### 3.3 消息处理流程

**执行步骤**:

```
TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
│
├─ 1. 参数验证
│   ├─ 检查 message 是否为字符串
│   └─ 检查 chatType 是否为团队/小队消息类型
│       └─ 只处理: RAID, RAID_WARNING, PARTY, INSTANCE_CHAT
│
├─ 2. 检查是否是自动消息
│   └─ IsAutoMessage(message)
│       ├─ 遍历所有消息模式
│       └─ 如果匹配 AirdropDetected 格式，返回 true
│           └─ 否则返回 false（可能是手动消息，跳过处理）
│
├─ 3. 解析消息，提取地图名称
│   └─ ParseTeamMessage(message)
│       ├─ 调用 IsAutoMessage() 确认是自动消息
│       ├─ 遍历所有消息模式，匹配地图名称
│       └─ 返回地图名称（去除首尾空格）
│
├─ 4. 根据地图名称获取地图ID
│   └─ GetMapIdByName(mapName)
│       ├─ 首先使用当前语言的地图名称匹配
│       └─ 如果失败，遍历所有语言的地图名称匹配
│
├─ 5. 检查是否是当前玩家发送的消息（防重复更新 #1）
│   └─ if sender == playerName or sender == fullPlayerName then
│       └─ return false  // 是自己发送的消息，不处理
│
├─ 6. 检查当前地图的 PROCESSED 状态（防重复更新 #2）
│   └─ if DetectionState:GetState(mapId).status == PROCESSED then
│       └─ if isOnMap then
│           └─ return false  // 当前地图且是 PROCESSED 状态，可能是自己发送的，跳过
│
├─ 7. 记录收到团队消息的时间
│   └─ lastTeamMessageTime[mapId] = currentTime
│       └─ 用于防止之后进入地图时重复通知
│
├─ 8. 检查是否应该更新刷新时间（防重复更新 #3）
│   └─ 时间窗口检查
│       ├─ 获取旧时间: oldTime = Data:GetMap(mapId).lastRefresh
│       ├─ 计算时间差异: timeDiff = math.abs(currentTime - oldTime)
│       └─ if timeDiff <= 30 then
│           └─ 时间差异在30秒内，视为同一空投
│               ├─ if currentTime < oldTime then
│               │   └─ refreshTime = currentTime  // 使用更早的时间
│               └─ else
│                   └─ shouldUpdate = false  // 保持旧时间（不更新）
│
├─ 9. 更新刷新时间（如果需要）
│   └─ if shouldUpdate then
│       └─ Data:SetLastRefresh(mapId, refreshTime)
│           ├─ mapData.lastRefresh = refreshTime
│           ├─ Data:UpdateNextRefresh(mapId)
│           └─ Data:SaveMapData(mapId)
│
├─ 10. 更新UI
│    └─ TimerManager:UpdateUI()
│        └─ MainPanel:UpdateTable()
│
└─ 11. 检查是否应该发送通知
    └─ if isOnMap then
        ├─ if DetectionState:GetState(mapId).status == PROCESSED then
        │   └─ shouldSend = false  // 空投还在进行中，不发送通知
        └─ if shouldSend then
            └─ Logger:Info("Notification", "通知", message)  // 发送系统通知
```

**关键代码位置**: `Modules/TeamMessageReader.lua:ProcessTeamMessage()` (第234-430行)

---

## 四、消息格式识别机制

### 4.1 消息格式区分

**自动消息格式** (AirdropDetected):
- 中文简体: `【%s】 检测到战争物资正在空投！！！`
- 中文繁体: `【%s】 檢測到戰爭物資正在空投！！！`
- 英文: `[%s] War Supply Crate airdrop detected!!!`
- 俄文: `[%s] Обнаружен сброс военных припасов!!!`

**手动消息格式** (AirdropDetectedManual):
- 中文简体: `【%s】 战争物资正在空投！！！`
- 中文繁体: `【%s】 戰爭物資正在空投！！！`
- 英文: `[%s] War Supply Crate airdrop in progress!!!`
- 俄文: `[%s] Сброс военных припасов в процессе!!!`

**区别**: 自动消息包含"检测到"关键字，手动消息不包含。

### 4.2 消息模式初始化

**执行步骤**:

```
InitializeMessagePatterns()
│
├─ 1. 清空现有模式
│   └─ messagePatterns = {}
│
├─ 2. 获取所有语言的消息格式
│   └─ 从 LocaleManager.GetLocaleRegistry() 获取
│       ├─ 遍历所有已注册的语言
│       ├─ 提取 AirdropDetected 格式
│       └─ 去重（避免重复的消息格式）
│
├─ 3. 回退方案（如果 LocaleManager 没有数据）
│   └─ 从当前语言获取 AirdropDetected 格式
│
└─ 4. 为每个消息格式创建匹配模式
    ├─ 转义特殊字符: %, (, ), [, ], !, +, -, *, ?, ^, $, .
    ├─ 将 %%%%s 替换为 (.+) 来匹配地图名称
    └─ 存储到 messagePatterns 数组
```

**关键代码位置**: `Modules/TeamMessageReader.lua:InitializeMessagePatterns()` (第30-113行)

### 4.3 消息匹配逻辑

**IsAutoMessage(message)**:

```
1. 检查消息是否为字符串
   └─ if not message or type(message) ~= "string" then return false

2. 遍历所有消息模式
   └─ for _, patternData in ipairs(messagePatterns) do
       └─ if message:match(patternData.pattern) then
           └─ return true  // 匹配成功，是自动消息

3. 如果都不匹配
   └─ return false  // 不是自动消息，可能是手动消息或其他消息
```

**ParseTeamMessage(message)**:

```
1. 调用 IsAutoMessage() 确认是自动消息
   └─ if not IsAutoMessage(message) then return nil

2. 遍历所有消息模式，匹配地图名称
   └─ for _, patternData in ipairs(messagePatterns) do
       └─ local mapName = message:match(patternData.pattern)
           └─ if mapName and mapName ~= "" then
               └─ return mapName:match("^%s*(.-)%s*$")  // 去除首尾空格
```

**关键代码位置**: 
- `Modules/TeamMessageReader.lua:IsAutoMessage()` (第118-137行)
- `Modules/TeamMessageReader.lua:ParseTeamMessage()` (第140-170行)

---

## 五、防重复更新机制详解

### 5.1 机制概览

团队消息读取功能包含三层防重复更新机制：

1. **自己发送的消息检查**: 跳过自己发送的消息
2. **PROCESSED状态检查**: 如果当前地图已经是PROCESSED状态，跳过处理
3. **时间窗口检查**: 如果时间差异≤30秒，使用更早的时间

### 5.2 机制 #1: 自己发送的消息检查

**目的**: 避免自己发送的自动检测消息导致重复更新

**实现**:

```
1. 获取当前玩家信息
   ├─ playerName = UnitName("player")
   ├─ realmName = GetRealmName()
   └─ fullPlayerName = playerName .. "-" .. realmName

2. 检查发送者
   └─ if sender == playerName or sender == fullPlayerName then
       └─ return false  // 是自己发送的消息，不处理
```

**场景**:
- 玩家在某个地图检测到空投
- 插件自动发送团队消息
- 自己的 `TeamMessageReader` 监听到这条消息
- 检查发送者，发现是自己，跳过处理

**关键代码位置**: `Modules/TeamMessageReader.lua:ProcessTeamMessage()` (第264-278行)

---

### 5.3 机制 #2: PROCESSED状态检查

**目的**: 如果当前地图已经是PROCESSED状态，说明是自己检测到的，跳过处理

**实现**:

```
1. 获取地图状态
   └─ state = DetectionState:GetState(mapId)

2. 检查状态
   └─ if state.status == PROCESSED then
       └─ 检查是否是当前地图
           └─ if isOnMap then
               └─ return false  // 当前地图且是 PROCESSED 状态，可能是自己发送的，跳过
```

**场景**:
- 玩家在某个地图检测到空投
- 插件自动发送团队消息并进入PROCESSED状态
- 收到其他用户的消息（可能是延迟到达）
- 检查状态，发现当前地图是PROCESSED状态，跳过处理

**关键代码位置**: `Modules/TeamMessageReader.lua:ProcessTeamMessage()` (第280-295行)

---

### 5.4 机制 #3: 时间窗口检查

**目的**: 防止多用户消息导致重复更新，使用更早的时间作为空投实际开始时间

**实现**:

```
1. 获取旧时间
   └─ oldTime = Data:GetMap(mapId).lastRefresh

2. 计算时间差异
   └─ timeDiff = math.abs(currentTime - oldTime)

3. 检查时间差异
   └─ if timeDiff <= 30 then
       └─ 时间差异在30秒内，视为同一空投
           ├─ if currentTime < oldTime then
           │   └─ refreshTime = currentTime  // 使用更早的时间
           └─ else
               └─ shouldUpdate = false  // 保持旧时间（不更新）
   └─ else
       └─ 时间差异超过30秒，视为新的空投，允许更新
```

**场景**:
- 用户A在 12:00:00 发送消息 → 更新刷新时间为 12:00:00
- 用户B在 12:00:05 发送消息 → 检查：时间差异5秒 < 30秒，且新时间不更早 → 保持 12:00:00（不更新）
- 用户C在 12:00:10 发送消息 → 检查：时间差异10秒 < 30秒，且新时间不更早 → 保持 12:00:00（不更新）

**关键代码位置**: `Modules/TeamMessageReader.lua:ProcessTeamMessage()` (第312-361行)

---

## 六、多语言支持

### 6.1 消息格式获取

**执行步骤**:

```
1. 从 LocaleManager 获取所有已注册的语言
   └─ localeRegistry = LocaleManager.GetLocaleRegistry()

2. 遍历所有语言，提取 AirdropDetected 格式
   └─ for locale, localeData in pairs(localeRegistry) do
       └─ if localeData.AirdropDetected then
           └─ 添加到 messageFormats 数组（去重）

3. 回退方案（如果 LocaleManager 没有数据）
   └─ 从当前语言获取 AirdropDetected 格式
```

### 6.2 地图名称匹配

**执行步骤**:

```
1. 首先使用当前语言的地图名称匹配
   └─ for _, mapData in ipairs(maps) do
       └─ displayName = Data:GetMapDisplayName(mapData)
           └─ if displayName == mapName then
               └─ return mapData.id

2. 如果失败，遍历所有语言的地图名称匹配
   └─ for _, mapData in ipairs(maps) do
       └─ for locale, localeData in pairs(localeRegistry) do
           └─ if localeData.MapNames[mapData.mapID] == mapName then
               └─ return mapData.id
```

**关键代码位置**: `Modules/TeamMessageReader.lua:GetMapIdByName()` (第173-214行)

---

## 七、通知机制

### 7.1 通知触发条件

**执行步骤**:

```
1. 检查当前是否在该地图上
   └─ isOnMap = (currentMapID == mapData.mapID)

2. 如果在地图上
   └─ 检查空投状态
       ├─ if DetectionState:GetState(mapId).status == PROCESSED then
       │   └─ shouldSend = false  // 空投还在进行中，不发送通知
       └─ if shouldSend then
           └─ Logger:Info("Notification", "通知", message)  // 发送系统通知

3. 如果不在该地图上
   └─ 不发送通知（但刷新时间已更新）
       └─ 如果之后进入该地图，且空投还在进行中，不会再次发送通知
```

### 7.2 通知冷却期

**目的**: 防止重复通知

**实现**:

```
1. 记录收到团队消息的时间
   └─ lastTeamMessageTime[mapId] = currentTime

2. 在 Timer.lua 中检查
   └─ if TeamMessageReader.lastTeamMessageTime[mapId] then
       └─ timeSinceTeamMessage = currentTime - lastTeamMessageTime
           └─ if timeSinceTeamMessage < 30 then
               └─ shouldSendNotification = false  // 不发送通知
```

**关键代码位置**: `Modules/Timer.lua:DetectMapIcons()` (第280-299行)

---

## 八、代码执行时序图

### 8.1 正常流程

```
时间轴: 0秒 → 1秒 → 2秒
        │     │     │
        │     │     └─ 用户B发送消息 → 时间窗口检查 → 保持旧时间（不更新）
        │     │
        │     └─ 用户A发送消息 → 更新刷新时间为 12:00:00
        │
        └─ 初始化 → 注册聊天消息监听
```

### 8.2 自己发送的消息流程

```
时间轴: 0秒 → 1秒 → 2秒
        │     │     │
        │     │     └─ 自己发送的消息 → 发送者检查 → 跳过处理
        │     │
        │     └─ 检测到空投 → 发送团队消息
        │
        └─ 初始化 → 注册聊天消息监听
```

### 8.3 多用户消息流程

```
时间轴: 0秒 → 5秒 → 10秒
        │     │     │
        │     │     └─ 用户C发送消息 → 时间窗口检查 → 保持旧时间（不更新）
        │     │
        │     └─ 用户B发送消息 → 时间窗口检查 → 保持旧时间（不更新）
        │
        └─ 用户A发送消息 → 更新刷新时间为 12:00:00
```

---

## 九、关键代码位置索引

### 9.1 初始化

- **TeamMessageReader:Initialize()**: `Modules/TeamMessageReader.lua` 第372-416行
- **InitializeMessagePatterns()**: `Modules/TeamMessageReader.lua` 第30-113行

### 9.2 消息处理

- **TeamMessageReader:ProcessTeamMessage()**: `Modules/TeamMessageReader.lua` 第234-430行
- **IsAutoMessage()**: `Modules/TeamMessageReader.lua` 第118-137行
- **ParseTeamMessage()**: `Modules/TeamMessageReader.lua` 第140-170行
- **GetMapIdByName()**: `Modules/TeamMessageReader.lua` 第173-214行

### 9.3 防重复机制

- **自己发送的消息检查**: `Modules/TeamMessageReader.lua` 第264-278行
- **PROCESSED状态检查**: `Modules/TeamMessageReader.lua` 第280-295行
- **时间窗口检查**: `Modules/TeamMessageReader.lua` 第312-361行

---

## 十、常见问题解答

### Q1: 为什么只处理自动消息，不处理手动消息？

**A**: 自动消息是插件检测到空投后自动发送的，时间戳准确。手动消息是用户手动触发的，可能不准确。只处理自动消息可以确保刷新时间的准确性。

### Q2: 时间窗口为什么是30秒？

**A**: 空投持续时间通常很短（几分钟），如果多个用户在30秒内报告，说明是同一个空投。30秒是一个合理的窗口期，既能防止重复更新，又不会错过新的空投。

### Q3: 如果时间差异正好30秒，会怎么处理？

**A**: 使用 `<=` 判断，所以30秒会被视为同一空投，使用更早的时间。

### Q4: 如果新时间比旧时间早很多（比如差异>30秒），会怎么处理？

**A**: 如果时间差异>30秒，会被视为新的空投，允许更新。但如果差异过大（比如几分钟），可能是时间同步问题，需要进一步检查。

### Q5: 为什么需要检查PROCESSED状态？

**A**: 如果当前地图已经是PROCESSED状态，说明是自己检测到的。此时收到其他用户的消息（可能是延迟到达），应该跳过处理，避免重复更新。

### Q6: 如果玩家在空投消息发送后1分钟才到达地图，会怎么处理？

**A**: 
1. 收到团队消息时，会更新刷新时间（使用消息发送时间）
2. 到达地图时，如果空投还在进行中（PROCESSED状态），不会再次发送通知
3. 刷新时间已经更新，下次刷新时间计算正确

---

## 十一、更新历史

- **2025-12-29**: 创建文档，详细说明团队消息读取更新机制

---

**文档维护者**: capzk  
**最后更新**: 2025-12-29

