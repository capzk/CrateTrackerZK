# 空投检测与通知机制详解

## 文档概述

本文档详细说明 CrateTrackerZK 插件中空投检测、时间更新、消息通知、防止重复、状态检查等机制的完整流程和代码执行步骤。

**版本**: 1.1.4.20251229_beta  
**最后更新**: 2025-12-29

---

## 一、核心机制概览

### 1.1 主要组件

- **TimerManager** (`Modules/Timer.lua`): 核心检测循环协调器，每1秒执行一次检测
- **IconDetector** (`Modules/IconDetector.lua`): 地图图标检测器，检测空投箱子图标
- **DetectionState** (`Modules/DetectionState.lua`): 状态机管理器，管理检测状态转换
- **Notification** (`Modules/Notification.lua`): 通知系统，处理自动和手动通知
- **Data** (`Data/Data.lua`): 数据管理器，处理刷新时间的更新和计算
- **MapTracker** (`Modules/MapTracker.lua`): 地图匹配和变化追踪
- **Area** (`Modules/Area.lua`): 区域有效性检测

### 1.2 状态机

检测状态机包含以下状态：

- **IDLE**: 空闲状态，未检测到图标
- **DETECTING**: 检测中，首次检测到图标，等待2秒确认
- **CONFIRMED**: 已确认，持续检测2秒后进入此状态
- **PROCESSED**: 已处理，已更新刷新时间和发送通知，暂停检测3分钟

### 1.3 防重复机制

1. **2秒持续检测确认**: 防止短暂图标闪烁导致的误判
2. **PROCESSED状态3分钟冷却期**: 防止重复检测和通知
3. **团队消息30秒冷却期**: 防止重复通知（如果30秒内收到团队消息，不发送通知）
4. **自己发送的消息检查**: 跳过自己发送的团队消息
5. **时间窗口检查**: 团队消息读取时，如果时间差异≤30秒，使用更早的时间

---

## 二、完整执行流程

### 2.1 初始化流程

**触发时机**: `PLAYER_LOGIN` 事件

**执行步骤**:

```
1. Core.lua:OnLogin()
   ├─ 初始化 SavedVariables (CRATETRACKERZK_UI_DB, CRATETRACKERZK_DB)
   ├─ 清除所有内存检测状态（防止跨角色污染）
   │   ├─ DetectionState:ClearAllStates()
   │   ├─ MapTracker:Initialize()
   │   └─ Phase:Reset()
   ├─ 初始化各模块
   │   ├─ Localization:Initialize()
   │   ├─ Data:Initialize()
   │   ├─ Notification:Initialize()
   │   └─ Commands:Initialize()
   ├─ 启动检测系统
   │   └─ TimerManager:StartMapIconDetection(1)  // 每1秒检测一次
   ├─ 创建UI界面
   │   ├─ MainPanel:CreateMainFrame()
   │   └─ FloatingButton:Create()
   └─ 检查区域有效性
       └─ Area:CheckAndUpdateAreaValid()
```

**关键代码位置**: `Core/Core.lua:OnLogin()`

---

### 2.2 检测循环流程（每1秒执行）

**触发时机**: `TimerManager:StartMapIconDetection(1)` 创建的定时器

**执行步骤**:

```
TimerManager:DetectMapIcons()  // 每1秒执行
│
├─ 1. 获取当前地图ID
│   └─ currentMapID = C_Map.GetBestMapForUnit("player")
│
├─ 2. 匹配目标地图数据
│   └─ targetMapData = MapTracker:GetTargetMapData(currentMapID)
│       ├─ 首先匹配当前地图ID
│       └─ 如果未匹配，尝试匹配父地图ID
│
├─ 3. 处理地图变化
│   └─ MapTracker:OnMapChanged(currentMapID, targetMapData, currentTime)
│       ├─ 检测游戏地图变化
│       ├─ 检测配置地图变化
│       └─ 记录离开地图时间
│
├─ 4. 检查 PROCESSED 状态（3分钟冷却期）
│   └─ if DetectionState:IsProcessed(targetMapData.id) then
│       ├─ if DetectionState:IsProcessedTimeout(targetMapData.id, currentTime) then
│       │   └─ DetectionState:ClearProcessed(targetMapData.id)  // 超时清除
│       └─ else
│           └─ return false  // 在冷却期内，跳过检测
│
├─ 5. 检测图标
│   └─ iconDetected = IconDetector:DetectIcon(currentMapID)
│       ├─ 获取所有Vignette图标: C_VignetteInfo.GetVignettes()
│       ├─ 遍历查找空投箱子（仅依赖名称匹配）
│       └─ 返回 true/false
│
├─ 6. 更新状态机
│   └─ state = DetectionState:UpdateState(targetMapData.id, iconDetected, currentTime)
│       ├─ IDLE → DETECTING: 首次检测到图标
│       │   └─ firstDetectedTime = currentTime
│       ├─ DETECTING → CONFIRMED: 持续检测2秒
│       │   └─ if (currentTime - firstDetectedTime) >= 2 then
│       │       └─ status = CONFIRMED
│       └─ 图标消失处理
│           ├─ DETECTING状态下消失: 清除状态，输出警告（如果<2秒）
│           └─ CONFIRMED状态下消失: 静默清除状态（已通过2秒确认）
│
└─ 7. 处理 CONFIRMED 状态
    └─ if state.status == DetectionState.STATES.CONFIRMED then
        ├─ 关键验证：再次检查图标是否仍然存在
        │   └─ currentIconDetected = IconDetector:DetectIcon(currentMapID)
        │       └─ if not currentIconDetected then
        │           └─ return false  // 图标已消失，跳过处理
        │
        ├─ 检查是否在30秒内收到过团队消息（防止重复通知）
        │   └─ if TeamMessageReader.lastTeamMessageTime[targetMapData.id] then
        │       ├─ timeSinceTeamMessage = currentTime - lastTeamMessageTime
        │       └─ if timeSinceTeamMessage < 30 then
        │           └─ shouldSendNotification = false  // 不发送通知
        │
        ├─ 发送通知（如果需要）
        │   └─ if shouldSendNotification then
        │       └─ Notification:NotifyAirdropDetected(mapName, MAP_ICON)
        │           ├─ 检查团队通知设置
        │           ├─ 如果在团队中且启用: SendChatMessage(message, RAID/RAID_WARNING)
        │           ├─ 如果在小队中且启用: SendChatMessage(message, PARTY)
        │           └─ 否则: Logger:Info()  // 系统消息
        │
        ├─ 更新刷新时间
        │   └─ Data:SetLastRefresh(targetMapData.id, state.firstDetectedTime)
        │       ├─ mapData.lastRefresh = timestamp
        │       ├─ mapData.lastRefreshInstance = mapData.instance
        │       ├─ Data:UpdateNextRefresh(mapId)
        │       └─ Data:SaveMapData(mapId)
        │
        ├─ 标记为已处理
        │   └─ DetectionState:MarkAsProcessed(targetMapData.id, currentTime)
        │       └─ processedTime[mapId] = currentTime  // 暂停检测3分钟
        │
        └─ 更新UI
            └─ TimerManager:UpdateUI()
                └─ MainPanel:UpdateTable()
```

**关键代码位置**: 
- `Modules/Timer.lua:DetectMapIcons()`
- `Modules/DetectionState.lua:UpdateState()`
- `Modules/Notification.lua:NotifyAirdropDetected()`

---

### 2.3 状态机详细流程

#### 2.3.1 状态转换规则

```
IDLE → DETECTING:
  条件: 首次检测到图标
  操作: firstDetectedTime = currentTime

DETECTING → CONFIRMED:
  条件: 持续检测2秒 (currentTime - firstDetectedTime >= 2)
  操作: status = CONFIRMED, isDetected = true

DETECTING → IDLE:
  条件: 图标消失（在2秒确认期内）
  操作: 清除 firstDetectedTime，输出警告（如果<2秒）

CONFIRMED → IDLE:
  条件: 图标消失（已通过2秒确认）
  操作: 静默清除状态（已通过2秒确认，视为有效空投）

CONFIRMED → PROCESSED:
  条件: 在 Timer.lua 中处理 CONFIRMED 状态后
  操作: processedTime[mapId] = currentTime

PROCESSED → IDLE:
  条件: 超时（3分钟后）
  操作: 清除 processedTime[mapId]
```

#### 2.3.2 状态检查逻辑

**DetectionState:GetState(mapId)**:

```lua
1. 获取状态数据
   ├─ firstDetectedTime = mapIconFirstDetectedTime[mapId]
   ├─ isDetected = mapIconDetected[mapId]
   ├─ lastUpdateTime = lastUpdateTime[mapId]
   └─ processedTime = processedTime[mapId]

2. 判断状态
   ├─ if processedTime then
   │   └─ return PROCESSED
   ├─ elseif isDetected then
   │   └─ if firstDetectedTime and not lastUpdateTime then
   │       └─ return CONFIRMED
   └─ elseif firstDetectedTime then
       └─ return DETECTING
   └─ else
       └─ return IDLE
```

**关键代码位置**: `Modules/DetectionState.lua:GetState()`

---

### 2.4 通知机制详解

#### 2.4.1 自动检测通知流程

**触发时机**: `Timer.lua` 中检测到 CONFIRMED 状态

**执行步骤**:

```
1. 检查是否应该发送通知
   ├─ 检查是否在30秒内收到过团队消息
   │   └─ if TeamMessageReader.lastTeamMessageTime[mapId] then
   │       └─ if (currentTime - lastTeamMessageTime) < 30 then
   │           └─ shouldSendNotification = false
   └─ 否则: shouldSendNotification = true

2. 如果应该发送通知
   └─ Notification:NotifyAirdropDetected(mapName, MAP_ICON)
       ├─ 构建消息: message = string.format(L["AirdropDetected"], mapName)
       │   └─ 格式: "【%s】 检测到战争物资正在空投！！！"
       │
       ├─ 获取团队聊天类型
       │   └─ chatType = Notification:GetTeamChatType()
       │       ├─ if IsInGroup(LE_PARTY_CATEGORY_INSTANCE) then return "INSTANCE_CHAT"
       │       ├─ if IsInRaid() then return "RAID"
       │       └─ if IsInGroup() then return "PARTY"
       │
       ├─ 发送通知
       │   ├─ 如果在团队中且 teamNotificationEnabled = true
       │   │   ├─ 检查权限: hasPermission = UnitIsGroupLeader() or UnitIsGroupAssistant()
       │   │   ├─ 如果有权限: SendChatMessage(message, "RAID_WARNING")
       │   │   └─ 否则: SendChatMessage(message, "RAID")
       │   │   └─ 不发送系统消息（避免重复显示）
       │   │
       │   ├─ 如果在小队中且 teamNotificationEnabled = true
       │   │   └─ SendChatMessage(message, "PARTY")
       │   │   └─ 不发送系统消息（避免重复显示）
       │   │
       │   └─ 否则（不在队伍中或团队通知已禁用）
       │       └─ Logger:Info("Notification", "通知", message)  // 系统消息
```

**关键代码位置**: 
- `Modules/Timer.lua:DetectMapIcons()` (第280-307行)
- `Modules/Notification.lua:NotifyAirdropDetected()`

#### 2.4.2 手动通知流程

**触发时机**: 用户点击主面板的"通知"按钮

**执行步骤**:

```
1. MainPanel:NotifyMap(mapId)
   └─ Notification:NotifyMapRefresh(mapData)

2. Notification:NotifyMapRefresh(mapData)
   ├─ 检查空投是否活跃
   │   └─ isAirdropActive = (DetectionState:GetState(mapData.id).status == PROCESSED)
   │
   ├─ 构建消息
   │   ├─ if isAirdropActive then
   │   │   └─ message = string.format(L["AirdropDetectedManual"], displayName)
   │   │       └─ 格式: "【%s】 战争物资正在空投！！！"（不带"检测到"关键字）
   │   └─ else
   │       ├─ if not remaining then
   │       │   └─ message = string.format(L["NoTimeRecord"], displayName)
   │       └─ else
   │           └─ message = string.format(L["TimeRemaining"], displayName, time)
   │
   └─ 发送通知
       ├─ if chatType then
       │   └─ SendChatMessage(message, chatType)  // 团队/小队消息
       │   └─ 不发送系统消息（避免重复显示）
       └─ else
           └─ Logger:Info("Notification", "通知", message)  // 系统消息
```

**关键代码位置**: `Modules/Notification.lua:NotifyMapRefresh()`

---

### 2.5 刷新时间更新流程

#### 2.5.1 自动检测更新

**触发时机**: `Timer.lua` 中检测到 CONFIRMED 状态

**执行步骤**:

```
1. Data:SetLastRefresh(mapId, timestamp)
   ├─ mapData.lastRefresh = timestamp  // 使用首次检测时间
   ├─ mapData.lastRefreshInstance = mapData.instance
   ├─ Data:UpdateNextRefresh(mapId)
   │   └─ mapData.nextRefresh = CalculateNextRefreshTime(lastRefresh, interval, currentTime)
   └─ Data:SaveMapData(mapId)
       └─ CRATETRACKERZK_DB.mapData[mapID] = {...}

2. DetectionState:SetLastUpdateTime(mapId, timestamp)
   └─ lastUpdateTime[mapId] = timestamp

3. DetectionState:MarkAsProcessed(mapId, currentTime)
   └─ processedTime[mapId] = currentTime  // 暂停检测3分钟

4. TimerManager:UpdateUI()
   └─ MainPanel:UpdateTable()  // 更新UI显示
```

**关键代码位置**: 
- `Data/Data.lua:SetLastRefresh()`
- `Modules/DetectionState.lua:MarkAsProcessed()`

#### 2.5.2 手动刷新按钮更新

**触发时机**: 用户点击主面板的"刷新"按钮

**执行步骤**:

```
1. MainPanel:RefreshMap(mapId)
   ├─ 立即更新内存数据（同步）
   │   ├─ mapData.lastRefresh = currentTimestamp
   │   ├─ mapData.lastRefreshInstance = mapData.instance
   │   └─ Data:UpdateNextRefresh(mapId, mapData)
   │
   ├─ 立即更新UI显示（同步）
   │   └─ MainPanel:UpdateTable()  // UI立即显示新时间
   │
   └─ 异步保存数据（异步）
       └─ C_Timer.After(0, function()
           └─ TimerManager:StartTimer(mapId, REFRESH_BUTTON, currentTimestamp)
               ├─ 检查数据是否已更新（避免重复更新）
               └─ if needsUpdate then
                   └─ Data:SetLastRefresh(mapId, timestamp)
                       └─ Data:SaveMapData(mapId)
```

**关键代码位置**: 
- `UI/MainPanel.lua:RefreshMap()`
- `Modules/Timer.lua:StartTimer()`

#### 2.5.3 手动输入时间更新

**触发时机**: 用户点击主面板的"编辑"按钮并输入时间

**执行步骤**:

```
1. MainPanel:EditLastRefresh(mapId)
   ├─ 弹出输入框
   └─ 用户输入时间（HH:MM:SS 或 HHMMSS）

2. 解析时间输入
   └─ Utils.ParseTimeInput(input)
       └─ 转换为时间戳: Utils.GetTimestampFromTime(hh, mm, ss)

3. TimerManager:StartTimer(mapId, MANUAL_INPUT, timestamp)
   ├─ Data:SetLastRefresh(mapId, timestamp)
   └─ TimerManager:UpdateUI()
       └─ MainPanel:UpdateTable()
```

**关键代码位置**: 
- `UI/MainPanel.lua:EditLastRefresh()`
- `Utils/Utils.lua:ParseTimeInput()`

---

## 三、防重复机制详解

### 3.1 2秒持续检测确认

**目的**: 防止短暂图标闪烁导致的误判

**实现**:

```
1. 首次检测到图标
   └─ DetectionState:UpdateState()
       └─ status = DETECTING
           └─ firstDetectedTime = currentTime

2. 持续检测2秒
   └─ 每1秒检查一次
       └─ if (currentTime - firstDetectedTime) >= 2 then
           └─ status = CONFIRMED

3. 如果图标在2秒内消失
   └─ DetectionState:UpdateState()
       └─ 清除 firstDetectedTime
           └─ 输出警告（如果<2秒）
```

**关键代码位置**: `Modules/DetectionState.lua:UpdateState()` (第89-104行)

---

### 3.2 PROCESSED状态3分钟冷却期

**目的**: 防止重复检测和通知

**实现**:

```
1. 标记为已处理
   └─ DetectionState:MarkAsProcessed(mapId, currentTime)
       └─ processedTime[mapId] = currentTime

2. 在检测循环中检查
   └─ TimerManager:DetectMapIcons()
       └─ if DetectionState:IsProcessed(mapId) then
           ├─ if DetectionState:IsProcessedTimeout(mapId, currentTime) then
           │   └─ DetectionState:ClearProcessed(mapId)  // 超时清除
           └─ else
               └─ return false  // 在冷却期内，跳过检测

3. 超时检查
   └─ DetectionState:IsProcessedTimeout(mapId, currentTime)
       └─ return (currentTime - processedTime) >= 180  // 3分钟
```

**关键代码位置**: 
- `Modules/DetectionState.lua:MarkAsProcessed()`
- `Modules/Timer.lua:DetectMapIcons()` (第227-240行)

---

### 3.3 团队消息30秒冷却期

**目的**: 防止重复通知（如果30秒内收到团队消息，不发送通知）

**实现**:

```
1. 记录收到团队消息的时间
   └─ TeamMessageReader.lastTeamMessageTime[mapId] = currentTime

2. 在检测到 CONFIRMED 状态时检查
   └─ TimerManager:DetectMapIcons()
       └─ if TeamMessageReader.lastTeamMessageTime[mapId] then
           └─ timeSinceTeamMessage = currentTime - lastTeamMessageTime
               └─ if timeSinceTeamMessage < 30 then
                   └─ shouldSendNotification = false  // 不发送通知
```

**关键代码位置**: `Modules/Timer.lua:DetectMapIcons()` (第280-299行)

---

### 3.4 自己发送的消息检查

**目的**: 跳过自己发送的团队消息，避免重复更新

**实现**:

```
1. 在 TeamMessageReader 中检查
   └─ TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
       └─ playerName = UnitName("player")
           └─ if sender == playerName or sender == fullPlayerName then
               └─ return false  // 是自己发送的消息，不处理
```

**关键代码位置**: `Modules/TeamMessageReader.lua:ProcessTeamMessage()` (第264-278行)

---

### 3.5 时间窗口检查（团队消息读取）

**目的**: 防止多用户消息导致重复更新，使用更早的时间作为空投实际开始时间

**实现**:

```
1. 获取旧时间
   └─ oldTime = Data:GetMap(mapId).lastRefresh

2. 检查时间差异
   └─ timeDiff = math.abs(currentTime - oldTime)
       └─ if timeDiff <= 30 then
           └─ 时间差异在30秒内，视为同一空投
               ├─ if currentTime < oldTime then
               │   └─ refreshTime = currentTime  // 使用更早的时间
               └─ else
                   └─ shouldUpdate = false  // 保持旧时间（不更新）

3. 如果时间差异 > 30秒
   └─ 视为新的空投，允许更新
```

**关键代码位置**: `Modules/TeamMessageReader.lua:ProcessTeamMessage()` (第312-361行)

---

## 四、状态检查机制

### 4.1 区域有效性检查

**目的**: 在副本/战场等无效区域自动暂停检测

**实现**:

```
1. Area:CheckAndUpdateAreaValid()
   ├─ 检查副本类型
   │   └─ instanceType = select(2, GetInstanceInfo())
   │       └─ if instanceType in ["party", "raid", "pvp", "arena", "scenario"] then
   │           └─ areaValid = false
   │
   ├─ 检查地图是否在追踪列表中
   │   └─ if not MapTracker:GetTargetMapData(currentMapID) then
   │       └─ areaValid = false
   │
   └─ 更新检测状态
       ├─ if areaValid and detectionPaused then
       │   └─ 恢复检测: TimerManager:StartMapIconDetection(1)
       └─ if not areaValid and not detectionPaused then
           └─ 暂停检测: TimerManager:StopMapIconDetection()
```

**关键代码位置**: `Modules/Area.lua:CheckAndUpdateAreaValid()`

---

### 4.2 PROCESSED状态超时检查

**目的**: 3分钟后自动清除 PROCESSED 状态，恢复检测

**实现**:

```
1. 在检测循环中检查
   └─ TimerManager:DetectMapIcons()
       └─ if DetectionState:IsProcessed(mapId) then
           └─ if DetectionState:IsProcessedTimeout(mapId, currentTime) then
               └─ DetectionState:ClearProcessed(mapId)
                   └─ 清除所有相关状态
```

**关键代码位置**: `Modules/Timer.lua:DetectMapIcons()` (第227-240行)

---

### 4.3 图标消失检查

**目的**: 处理图标消失的情况，区分无效空投和正常消失

**实现**:

```
1. 在状态更新中检查
   └─ DetectionState:UpdateState(mapId, iconDetected, currentTime)
       └─ if not iconDetected then
           ├─ if status == DETECTING then
           │   └─ 图标在2秒确认期内消失
           │       ├─ if timeSinceFirstDetection < 2 then
           │       │   └─ 输出警告: 无效空投
           │       └─ else
           │           └─ 静默清除状态
           └─ if status == CONFIRMED then
               └─ 图标在确认后消失
                   └─ 静默清除状态（已通过2秒确认，视为有效空投）
```

**关键代码位置**: `Modules/DetectionState.lua:UpdateState()` (第105-136行)

---

## 五、代码执行时序图

### 5.1 正常检测流程

```
时间轴: 0秒 → 1秒 → 2秒 → 3秒
        │     │     │     │
        │     │     │     └─ CONFIRMED → PROCESSED
        │     │     │         ├─ 发送通知
        │     │     │         ├─ 更新刷新时间
        │     │     │         └─ 标记为已处理
        │     │     │
        │     │     └─ DETECTING → CONFIRMED (持续2秒)
        │     │
        │     └─ IDLE → DETECTING (首次检测到图标)
        │
        └─ IDLE (初始状态)
```

### 5.2 图标消失流程

```
时间轴: 0秒 → 1秒 → 2秒 → 3秒
        │     │     │     │
        │     │     │     └─ 图标消失 → IDLE (静默清除)
        │     │     │
        │     │     └─ DETECTING → CONFIRMED (持续2秒)
        │     │
        │     └─ IDLE → DETECTING (首次检测到图标)
        │
        └─ IDLE (初始状态)
```

### 5.3 无效空投流程

```
时间轴: 0秒 → 1秒 → 2秒
        │     │     │
        │     │     └─ 图标消失 → IDLE (输出警告: 无效空投)
        │     │
        │     └─ IDLE → DETECTING (首次检测到图标)
        │
        └─ IDLE (初始状态)
```

---

## 六、关键代码位置索引

### 6.1 检测循环

- **TimerManager:DetectMapIcons()**: `Modules/Timer.lua` 第200-338行
- **TimerManager:StartMapIconDetection()**: `Modules/Timer.lua` 第340-359行

### 6.2 状态管理

- **DetectionState:UpdateState()**: `Modules/DetectionState.lua` 第73-152行
- **DetectionState:GetState()**: `Modules/DetectionState.lua` 第44-71行
- **DetectionState:MarkAsProcessed()**: `Modules/DetectionState.lua` 第168-174行
- **DetectionState:IsProcessedTimeout()**: `Modules/DetectionState.lua` 第159-166行

### 6.3 通知系统

- **Notification:NotifyAirdropDetected()**: `Modules/Notification.lua` 第47-89行
- **Notification:NotifyMapRefresh()**: `Modules/Notification.lua` 第98-150行

### 6.4 数据更新

- **Data:SetLastRefresh()**: `Data/Data.lua` 第203-225行
- **Data:UpdateNextRefresh()**: `Data/Data.lua` 第174-201行

### 6.5 防重复机制

- **时间窗口检查**: `Modules/TeamMessageReader.lua` 第312-361行
- **自己发送的消息检查**: `Modules/TeamMessageReader.lua` 第264-278行
- **PROCESSED状态检查**: `Modules/Timer.lua` 第227-240行
- **团队消息冷却期检查**: `Modules/Timer.lua` 第280-299行

---

## 七、常见问题解答

### Q1: 为什么需要2秒持续检测确认？

**A**: 防止短暂图标闪烁导致的误判。空投箱子图标可能会出现短暂的闪烁，如果立即处理，会导致误报。通过2秒持续检测，可以过滤掉这些短暂闪烁。

### Q2: PROCESSED状态为什么要暂停检测3分钟？

**A**: 防止重复检测和通知。空投是持续事件，在空投进行期间，图标会一直存在。如果不暂停检测，每1秒都会重新检测到图标，导致重复更新和通知。3分钟冷却期可以确保在空投进行期间不会重复处理。

### Q3: 为什么团队消息有30秒冷却期？

**A**: 防止重复通知。如果30秒内收到团队消息，说明空投已经被其他玩家报告了，不需要再次发送通知。超过30秒后，空投可能已经结束，再发送通知也没有意义。

### Q4: 为什么需要检查自己发送的消息？

**A**: 避免重复更新。当自己发送自动检测消息时，`TeamMessageReader` 也会监听到这条消息。如果不检查，会导致重复更新刷新时间。

### Q5: 时间窗口检查的作用是什么？

**A**: 防止多用户消息导致重复更新。当多个用户在不同时间发送消息时，使用更早的时间作为空投实际开始时间，确保刷新时间准确。

---

## 八、更新历史

- **2025-12-29**: 创建文档，详细说明空投检测与通知机制

---

**文档维护者**: capzk  
**最后更新**: 2025-12-29

