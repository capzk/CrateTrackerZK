# 团队通知机制详解

## 目录

1. [概述](#概述)
2. [通知类型](#通知类型)
3. [30秒限制机制](#30秒限制机制)
4. [个人发送限制](#个人发送限制)
5. [首次通知时间记录](#首次通知时间记录)
6. [团队消息检测](#团队消息检测)
7. [新事件重置机制](#新事件重置机制)
8. [开关控制](#开关控制)
9. [手动通知](#手动通知)
10. [数据结构和存储](#数据结构和存储)
11. [完整工作流程](#完整工作流程)
12. [代码实现位置](#代码实现位置)

---

## 概述

团队通知机制是 CrateTrackerZK 插件的核心功能之一，用于在团队/小队中自动通知空投事件。该机制包含以下核心特性：

- **30秒限制机制**：从首次通知开始计时，30秒内允许其他玩家发送通知，超过30秒停止发送
- **个人发送限制**：每个玩家对同一个地图的同一个空投事件只能自动发送一次通知
- **团队消息同步**：通过检测团队消息更新首次通知时间，所有玩家共享
- **新事件重置**：检测到新的空投事件时，清除通知记录，重新开始计时

---

## 通知类型

### 1. 自动检测通知（NotifyAirdropDetected）

**触发条件**：
- 插件自动检测到空投事件（通过地图图标检测）
- 经过2秒确认机制验证

**消息格式**：
- 中文：`【地图名称】 检测到战争物资正在空投！！！`
- 英文：`[Map Name] War supplies airdrop detected!!!`

**发送渠道**：
- 如果在团队中：发送到团队聊天（RAID/RAID_WARNING/PARTY/INSTANCE_CHAT）
- 如果不在团队中：仅发送系统消息

**权限处理**：
- 如果在团队中且有权限（队长/助理）：发送到 RAID_WARNING
- 如果在团队中但无权限：发送到 RAID
- 如果在小队中：发送到 PARTY 或 INSTANCE_CHAT

### 2. 手动通知（NotifyMapRefresh）

**触发条件**：
- 用户点击UI面板的"通知"按钮

**消息格式**：
- 如果空投进行中：`【地图名称】 战争物资正在空投！！！`
- 如果空投未进行中：`【地图名称】 还剩 XX:XX:XX`

**发送渠道**：
- 如果在团队中：发送到团队聊天
- 如果不在团队中：仅发送系统消息

**状态判断**：
- 在当前地图：实时检测飞机图标是否存在
  - 图标存在 → 发送"空投进行中"消息
  - 图标不存在 → 发送"剩余时间"消息
- 不在当前地图：直接发送"剩余时间"消息

### 3. 无效空投通知（NotifyInvalidAirdrop）

**触发条件**：
- 2秒确认期后，图标消失或 objectGUID 不同

**消息格式**：
- `【地图名称】 检测到无效空投`

**发送渠道**：
- 仅发送系统消息（不发送到团队）

---

## 30秒限制机制

### 核心原则

**从首次通知开始计时，30秒内允许其他玩家发送通知，超过30秒停止发送**

### 机制说明

1. **首次通知**：
   - 当第一个玩家检测到空投并发送通知时，记录首次通知时间
   - 首次通知不受30秒限制（因为是实时检测，timeSinceDetection ≈ 2秒）

2. **后续通知**：
   - 其他玩家检测到空投时，检查距离首次通知是否超过30秒
   - 如果 ≤ 30秒：允许发送通知
   - 如果 > 30秒：不允许发送通知（防止旧空投通知）

3. **时间同步**：
   - 通过检测团队消息中的空投通知来更新首次通知时间
   - 所有玩家共享首次通知时间，确保30秒限制对所有玩家生效

### 实现逻辑

```lua
-- 检查是否允许发送通知
function Notification:CanSendNotification(mapName)
    local currentTime = time();
    local firstNotificationTime = self.firstNotificationTime[mapName];
    
    -- 如果没有首次通知时间，允许发送（首次通知）
    if not firstNotificationTime then
        return true;
    end
    
    -- 检查距离首次通知是否超过30秒
    local timeSinceFirstNotification = currentTime - firstNotificationTime;
    if timeSinceFirstNotification > 30 then
        return false;  -- 超过30秒，不允许发送
    end
    
    return true;  -- 30秒内，允许发送
end
```

### 应用场景

**场景1：正常流程**
```
T=0秒：玩家A检测到空投，发送通知（首次通知）
T=5秒：玩家B检测到空投，检查：距离首次通知5秒 ≤ 30秒 → 允许发送
T=15秒：玩家C检测到空投，检查：距离首次通知15秒 ≤ 30秒 → 允许发送
T=35秒：玩家D检测到空投，检查：距离首次通知35秒 > 30秒 → 不允许发送
```

**场景2：延迟进入地图**
```
T=0秒：玩家A检测到空投，发送通知（首次通知）
T=40秒：玩家B刚进入地图，检测到空投，检查：距离首次通知40秒 > 30秒 → 不允许发送
```

---

## 个人发送限制

### 核心原则

**每个玩家对同一个地图的同一个空投事件只能自动发送一次通知**

### 机制说明

1. **发送标记**：
   - 当玩家发送通知后，标记该玩家已发送（针对当前空投事件）
   - 使用 `playerSentNotification[mapName] = true` 记录

2. **重复检测**：
   - 如果玩家再次检测到同一空投事件（相同 objectGUID），检查是否已发送过
   - 如果已发送过：跳过发送，只发送系统消息
   - 如果未发送过：正常发送通知

3. **新事件重置**：
   - 当检测到新的空投事件（objectGUID不同）时，清除该地图的发送标记
   - 允许玩家在新事件中再次发送通知（因为这是新的空投事件）

### 实现逻辑

```lua
-- 检查玩家是否已发送过通知
function Notification:HasPlayerSentNotification(mapName)
    return self.playerSentNotification[mapName] == true;
end

-- 标记玩家已发送通知
function Notification:MarkPlayerSentNotification(mapName)
    self.playerSentNotification[mapName] = true;
end
```

### 应用场景

**场景1：同一空投事件多次检测**
```
玩家A检测到空投 → 发送通知 → 标记已发送
玩家A再次检测到同一空投 → 检查已发送 → 跳过发送
```

**场景2：新空投事件**
```
玩家A检测到空投1 → 发送通知 → 标记已发送
新空投事件2开始 → 清除发送标记
玩家A检测到空投2 → 发送通知 → 标记已发送
```

---

## 首次通知时间记录

### 数据结构

```lua
Notification.firstNotificationTime = {
    ["地图名称1"] = timestamp1,
    ["地图名称2"] = timestamp2,
    ...
}
```

### 更新机制

1. **自动检测更新**：
   - 当玩家首次检测到空投并发送通知时，记录当前时间作为首次通知时间
   - 如果该地图还没有首次通知时间，则记录

2. **团队消息更新**：
   - 当检测到团队消息中的空投通知时，更新首次通知时间
   - 如果新时间更早，则更新（确保记录最早的首次通知时间）

### 实现逻辑

```lua
-- 更新首次通知时间
function Notification:UpdateFirstNotificationTime(mapName, notificationTime)
    -- 如果还没有首次通知时间，或者新时间更早，则更新
    if not self.firstNotificationTime[mapName] or notificationTime < self.firstNotificationTime[mapName] then
        self.firstNotificationTime[mapName] = notificationTime;
    end
end
```

### 应用场景

**场景1：多个玩家同时检测**
```
T=0秒：玩家A检测到空投，发送通知，记录首次通知时间 = T=0秒
T=2秒：玩家B检测到空投，检查首次通知时间 = T=0秒，距离2秒 ≤ 30秒 → 允许发送
T=5秒：玩家C检测到空投，检查首次通知时间 = T=0秒，距离5秒 ≤ 30秒 → 允许发送
```

**场景2：团队消息同步**
```
T=0秒：玩家A检测到空投，发送通知（玩家A本地记录首次通知时间 = T=0秒）
T=1秒：玩家B收到团队消息，更新首次通知时间 = T=0秒（从消息时间推断）
T=3秒：玩家B检测到空投，检查首次通知时间 = T=0秒，距离3秒 ≤ 30秒 → 允许发送
```

---

## 团队消息检测

### 核心功能

**检测团队消息中的空投通知，用于更新首次通知时间和时间共享**

### 检测机制

1. **消息监听**：
   - 监听以下聊天事件：`CHAT_MSG_RAID`、`CHAT_MSG_RAID_WARNING`、`CHAT_MSG_PARTY`、`CHAT_MSG_INSTANCE_CHAT`
   - 始终运行，不受开关影响

2. **消息解析**：
   - 匹配自动通知消息格式（通过本地化系统支持多语言）
   - 提取地图名称
   - 跳过自己发送的消息

3. **首次通知时间更新**：
   - 当检测到团队消息中的空投通知时，调用 `Notification:UpdateFirstNotificationTime` 更新首次通知时间
   - 使用收到消息的时间作为通知时间（`currentTime = time()`）

### 实现逻辑

```lua
-- TeamMessageReader:ProcessTeamMessage
function TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
    -- 解析消息，提取地图名称
    local mapName = ParseTeamMessage(message);
    
    -- 更新首次通知时间（用于30秒限制机制）
    if Notification and Notification.UpdateFirstNotificationTime then
        Notification:UpdateFirstNotificationTime(mapName, currentTime);
    end
    
    -- 处理时间更新（如果开关开启）
    ...
end
```

### 应用场景

**场景1：团队消息同步首次通知时间**
```
T=0秒：玩家A检测到空投，发送通知到团队
T=1秒：玩家B收到团队消息，更新首次通知时间 = T=0秒（从消息推断）
T=2秒：玩家B检测到空投，检查首次通知时间 = T=0秒，距离2秒 ≤ 30秒 → 允许发送
```

**场景2：多个玩家同时发送**
```
T=0秒：玩家A检测到空投，发送通知，记录首次通知时间 = T=0秒
T=1秒：玩家B检测到空投，发送通知，记录首次通知时间 = T=1秒（但不会更新，因为T=0秒更早）
T=2秒：玩家C收到两个团队消息，更新首次通知时间 = T=0秒（取最早的时间）
```

---

## 新事件重置机制

### 核心原则

**当检测到新的空投事件（objectGUID不同）时，清除该地图的通知记录，重新开始30秒计时**

### 重置时机

1. **objectGUID 比对**：
   - 当检测到新的空投事件时，objectGUID 与存储的不同
   - 清除该地图的首次通知时间记录
   - 清除该地图的玩家发送通知记录

2. **检测状态变化**：
   - 在2秒确认期内，如果检测到 objectGUID 不同，视为新事件
   - 清除旧的检测状态，开始新的检测流程

### 实现逻辑

```lua
-- Timer.lua: 检测到新空投事件
if targetMapData.currentAirdropObjectGUID and targetMapData.currentAirdropObjectGUID ~= objectGUID then
    -- 检测到不同的 objectGUID，是新空投事件：清除该地图的通知记录
    local mapDisplayName = Data:GetMapDisplayName(targetMapData);
    if Notification then
        if Notification.firstNotificationTime and Notification.firstNotificationTime[mapDisplayName] then
            Notification.firstNotificationTime[mapDisplayName] = nil;
        end
        if Notification.playerSentNotification and Notification.playerSentNotification[mapDisplayName] then
            Notification.playerSentNotification[mapDisplayName] = nil;
        end
    end
end
```

### 应用场景

**场景1：新空投事件开始**
```
空投事件1：
T=0秒：玩家A检测到空投1，发送通知，记录首次通知时间 = T=0秒
T=10秒：玩家B检测到空投1，检查：距离首次通知10秒 ≤ 30秒 → 允许发送

空投事件2（新事件，objectGUID不同）：
T=1200秒：玩家A检测到空投2，清除通知记录，发送通知，记录首次通知时间 = T=1200秒
T=1205秒：玩家B检测到空投2，检查：距离首次通知5秒 ≤ 30秒 → 允许发送
```

---

## 开关控制

### 团队通知开关（teamNotificationEnabled）

**命令**：`/ctk team on/off`

**功能**：
- 控制是否发送团队通知
- 关闭时：仅发送系统消息，不发送到团队聊天
- 开启时：发送到团队聊天和系统消息

**存储位置**：`CRATETRACKERZK_UI_DB.teamNotificationEnabled`

**默认值**：`true`（开启）

### 团队时间共享开关（teamTimeShareEnabled）

**命令**：`/ctk timeshare on/off`

**功能**：
- 控制是否通过团队消息更新时间
- 关闭时：检测团队消息但不更新时间（仍会更新首次通知时间）
- 开启时：检测团队消息并更新时间

**存储位置**：`CRATETRACKERZK_UI_DB.teamTimeShareEnabled`

**默认值**：`false`（关闭，测试功能）

**重要说明**：
- 团队消息检测模块始终运行，不受此开关影响
- 此开关只控制时间更新功能，不控制消息检测
- 即使关闭，仍会更新首次通知时间（用于30秒限制机制）

---

## 手动通知

### 触发方式

用户点击UI面板的"通知"按钮

### 判断逻辑

1. **在当前地图**：
   - 实时检测飞机图标是否存在
   - 图标存在 → 发送"空投进行中"消息
   - 图标不存在 → 发送"剩余时间"消息

2. **不在当前地图**：
   - 直接发送"剩余时间"消息

### 限制机制

**手动通知不受30秒限制和个人发送限制影响**

- 可以随时点击通知按钮发送消息
- 不受 `firstNotificationTime` 和 `playerSentNotification` 限制
- 这是用户主动操作，应该允许

### 实现逻辑

```lua
-- MainPanel:NotifyMapRefresh
function MainPanel:NotifyMapRefresh(mapData)
    -- 实时检测飞机图标是否存在
    if currentMapID and mapData.mapID == currentMapID then
        local iconResult = IconDetector:DetectIcon(currentMapID);
        if iconResult and iconResult.detected then
            isAirdropActive = true;  -- 空投进行中
        end
    end
    
    -- 调用通知模块
    Notification:NotifyMapRefresh(mapData, isAirdropActive)
end
```

---

## 数据结构和存储

### 内存数据结构

```lua
Notification = {
    -- 初始化状态
    isInitialized = false,
    
    -- 团队通知开关
    teamNotificationEnabled = true,
    
    -- 首次通知时间记录（按地图名称索引）
    firstNotificationTime = {
        ["地图名称1"] = timestamp1,
        ["地图名称2"] = timestamp2,
        ...
    },
    
    -- 玩家发送通知记录（按地图名称索引）
    playerSentNotification = {
        ["地图名称1"] = true,
        ["地图名称2"] = true,
        ...
    }
}
```

### 持久化存储

**团队通知开关**：
- 存储位置：`CRATETRACKERZK_UI_DB.teamNotificationEnabled`
- 类型：`boolean`
- 默认值：`true`

**团队时间共享开关**：
- 存储位置：`CRATETRACKERZK_UI_DB.teamTimeShareEnabled`
- 类型：`boolean`
- 默认值：`false`

**注意**：
- `firstNotificationTime` 和 `playerSentNotification` 不持久化
- 每次登录时清除（在 `Core.lua` 的 `OnLogin` 中）
- 每次清除命令时清除（在 `Commands.lua` 的 `HandleClearCommand` 中）

---

## 完整工作流程

### 场景1：正常流程（多个玩家同时检测）

```
时间线：
T=0秒：
  - 玩家A检测到空投（首次检测）
  - 检查：首次通知时间 = nil → 允许发送
  - 检查：玩家A未发送过 → 允许发送
  - 发送通知到团队
  - 记录首次通知时间 = T=0秒
  - 标记玩家A已发送

T=2秒：
  - 玩家B检测到空投
  - 检查：首次通知时间 = T=0秒，距离2秒 ≤ 30秒 → 允许发送
  - 检查：玩家B未发送过 → 允许发送
  - 发送通知到团队
  - 标记玩家B已发送

T=5秒：
  - 玩家C检测到空投
  - 检查：首次通知时间 = T=0秒，距离5秒 ≤ 30秒 → 允许发送
  - 检查：玩家C未发送过 → 允许发送
  - 发送通知到团队
  - 标记玩家C已发送

T=35秒：
  - 玩家D检测到空投
  - 检查：首次通知时间 = T=0秒，距离35秒 > 30秒 → 不允许发送
  - 跳过发送，只发送系统消息
```

### 场景2：团队消息同步

```
时间线：
T=0秒：
  - 玩家A检测到空投，发送通知到团队
  - 玩家A本地记录首次通知时间 = T=0秒

T=1秒：
  - 玩家B收到团队消息
  - 更新首次通知时间 = T=0秒（从消息时间推断）
  - 如果开关开启：更新时间戳

T=3秒：
  - 玩家B检测到空投
  - 检查：首次通知时间 = T=0秒，距离3秒 ≤ 30秒 → 允许发送
  - 检查：玩家B未发送过 → 允许发送
  - 发送通知到团队
  - 标记玩家B已发送
```

### 场景3：新空投事件

```
时间线：
空投事件1：
T=0秒：
  - 玩家A检测到空投1，发送通知
  - 记录首次通知时间 = T=0秒
  - 标记玩家A已发送

T=10秒：
  - 玩家B检测到空投1，发送通知
  - 标记玩家B已发送

空投事件2（新事件，objectGUID不同）：
T=1200秒：
  - 玩家A检测到空投2（objectGUID不同）
  - 清除通知记录（首次通知时间、玩家发送记录）
  - 发送通知
  - 记录首次通知时间 = T=1200秒
  - 标记玩家A已发送

T=1205秒：
  - 玩家B检测到空投2
  - 检查：首次通知时间 = T=1200秒，距离5秒 ≤ 30秒 → 允许发送
  - 检查：玩家B未发送过（已清除） → 允许发送
  - 发送通知
  - 标记玩家B已发送
```

### 场景4：延迟进入地图

```
时间线：
T=0秒：
  - 玩家A检测到空投，发送通知
  - 记录首次通知时间 = T=0秒

T=40秒：
  - 玩家B刚进入地图，检测到空投
  - 检查：首次通知时间 = T=0秒，距离40秒 > 30秒 → 不允许发送
  - 跳过发送，只发送系统消息
  - 不标记玩家B已发送（因为未发送）
```

---

## 重载插件处理

### 重载后的处理流程

当玩家在空投事件进行中重载插件（`/reload`）时，处理流程如下：

1. **插件重新初始化**：
   - `Core.lua` 的 `OnLogin()` 会清除通知记录（`firstNotificationTime` 和 `playerSentNotification`）
   - 但是，`currentAirdropObjectGUID` 是持久化的（保存在 SavedVariables 中）
   - `Data.lua` 会从 SavedVariables 加载 `currentAirdropObjectGUID`

2. **检测系统启动**：
   - `TimerManager:StartMapIconDetection(1)` 启动检测循环
   - 检测系统开始检测空投图标

3. **检测到空投时的处理**：
   - 检测到空投图标，提取 `objectGUID`
   - 进行 objectGUID 比对（`Timer.lua` 第289行）
   - 如果 `targetMapData.currentAirdropObjectGUID == objectGUID`：
     - **跳过通知**：不发送通知（因为已经发送过了）
     - **跳过更新时间**：不更新 `lastRefresh` 和 `currentAirdropTimestamp`（因为这是同一个空投事件）
     - **更新活跃状态**：只更新 `airdropActiveTimestamp`（内存变量，用于通知按钮判断）
     - 返回 `true`，跳过后续处理

4. **结论**：
   - ✅ 重载后能够正确识别是同一个空投事件（通过 objectGUID 比对）
   - ✅ 不会重复发送通知
   - ✅ 不会错误更新时间
   - ✅ 通知记录被清除不影响 objectGUID 比对机制（因为 objectGUID 比对是主要机制）

### 重载后比对逻辑（可选）

**代码位置**：`Timer.lua` 第326-334行

```lua
-- 重载后比对（仅在团队时间共享功能启用时执行）
local teamTimeShareEnabled = CRATETRACKERZK_UI_DB and CRATETRACKERZK_UI_DB.teamTimeShareEnabled;
if teamTimeShareEnabled and TeamMessageReader and TeamMessageReader.CheckHistoricalObjectGUID then
    if TeamMessageReader:CheckHistoricalObjectGUID(targetMapData.id, objectGUID) then
        -- 跳过处理
        return true;
    end
end
```

**说明**：
- 这个逻辑是冗余的，因为第289行的 objectGUID 比对已经处理了重载后的情况
- 只在团队时间共享功能启用时执行
- 不影响核心功能

---

## 代码实现位置

### 核心模块

1. **Notification.lua**：
   - `NotifyAirdropDetected()`：自动检测通知
   - `NotifyMapRefresh()`：手动通知
   - `UpdateFirstNotificationTime()`：更新首次通知时间
   - `CanSendNotification()`：检查30秒限制
   - `HasPlayerSentNotification()`：检查个人发送限制
   - `MarkPlayerSentNotification()`：标记玩家已发送

2. **TeamMessageReader.lua**：
   - `ProcessTeamMessage()`：处理团队消息
   - `UpdateFirstNotificationTime()`：更新首次通知时间（调用Notification模块）
   - `CheckHistoricalObjectGUID()`：重载后比对（可选，冗余）

3. **Timer.lua**：
   - objectGUID 比对（第289行）：主要的重载后处理机制
   - 检测到新空投事件时清除通知记录
   - 调用 `NotifyAirdropDetected()` 发送通知

4. **MainPanel.lua**：
   - `NotifyMapRefresh()`：手动通知（实时检测图标）

### 清理机制

1. **Core.lua**：
   - `OnLogin()`：登录/重载时清除通知记录（但不影响 objectGUID 比对）

2. **Commands.lua**：
   - `HandleClearCommand()`：清除命令时清除通知记录

---

## 总结

团队通知机制通过以下机制确保通知的及时性和准确性：

1. **30秒限制机制**：从首次通知开始计时，30秒内允许其他玩家发送，超过30秒停止
2. **个人发送限制**：每个玩家对同一个地图的同一个空投事件只能自动发送一次
3. **首次通知时间记录**：通过自动检测和团队消息同步，确保所有玩家共享首次通知时间
4. **新事件重置**：检测到新的空投事件时，清除通知记录，允许玩家在新事件中再次发送
5. **团队消息检测**：始终运行，不受开关影响，用于同步首次通知时间

这些机制共同确保了：
- 空投事件能够及时通知团队
- 防止重复通知和旧空投通知
- 所有玩家共享通知状态
- 新事件能够正常通知

---

**最后更新**：2024-12-29  
**维护者**：capzk

