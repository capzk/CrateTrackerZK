# 团队时间共享机制确认报告

## 一、命令开关检查

### 1. 命令定义
- **命令**：`/ctk timeshare on/off` 或 `/ctk sharetime on/off`
- **处理函数**：`Commands:HandleTeamTimeShareCommand()`
- **代码位置**：`Modules/Commands.lua` 第 163-180 行

### 2. 开关存储
- **存储位置**：`CRATETRACKERZK_UI_DB.teamTimeShareEnabled`
- **数据类型**：boolean
- **默认值**：`false`（关闭）
- **初始化位置**：`Core/Core.lua` 第 22-24 行

### 3. 开关检查点
✅ **TeamMessageReader.lua 第196行**：
```lua
if not CRATETRACKERZK_UI_DB or not CRATETRACKERZK_UI_DB.teamTimeShareEnabled then
    return false;  -- 功能关闭，直接返回，不处理团队消息
end
```

✅ **Timer.lua 第306行**（重载后比对）：
```lua
local teamTimeShareEnabled = CRATETRACKERZK_UI_DB and CRATETRACKERZK_UI_DB.teamTimeShareEnabled;
if teamTimeShareEnabled and TeamMessageReader and TeamMessageReader.CheckHistoricalObjectGUID then
    -- 仅在功能启用时执行重载后比对
end
```

✅ **Timer.lua 第367行**（判断是否已通过团队时间共享更新）：
```lua
local teamTimeShareEnabled = CRATETRACKERZK_UI_DB and CRATETRACKERZK_UI_DB.teamTimeShareEnabled;
if teamTimeShareEnabled and targetMapData.currentAirdropTimestamp and targetMapData.lastRefresh then
    -- 仅在功能启用时判断
end
```

### 4. 命令开关有效性
✅ **确认有效**：
- 命令可以正确开启/关闭功能
- 所有相关检查点都正确检查开关状态
- 功能关闭时，团队消息不会被处理
- 功能关闭时，不会判断是否已通过团队时间共享更新

---

## 二、团队时间共享机制检查

### 1. 消息监听
✅ **监听频道**：
- `CHAT_MSG_RAID`
- `CHAT_MSG_RAID_WARNING`
- `CHAT_MSG_PARTY`
- `CHAT_MSG_INSTANCE_CHAT`

✅ **消息格式匹配**：
- 匹配插件自动发送的消息格式（`AirdropDetected`）
- 支持多语言格式匹配
- 提取地图名称

### 2. 消息过滤
✅ **跳过自己发送的消息**：
- 检查发送者是否为当前玩家
- 支持跨服务器玩家名称（`playerName-realmName`）

✅ **功能开关检查**：
- 如果功能关闭，直接返回，不处理消息

### 3. 处理逻辑

#### 情况A：不在空投地图的玩家

**处理流程**：
1. ✅ 检查30秒时间窗口（防止同一空投的多次消息重复更新）
   - 如果新消息时间在30秒内，且新时间更晚，跳过更新
   - 这是合理的，防止同一空投的多次消息重复更新
2. ✅ **无条件更新**时间为收到消息时的时间戳
   - `lastRefresh = currentTime`（收到消息时的时间）
   - `currentAirdropTimestamp = currentTime`
   - `currentAirdropObjectGUID = nil`（等待飞到空投地图后补齐）
3. ✅ 保存数据到 SavedVariables
4. ✅ 更新UI显示

**代码位置**：`Modules/TeamMessageReader.lua` 第 255-293 行

#### 情况B：在空投地图的玩家

**处理流程**：
1. ✅ 跳过处理（由本地检测系统处理）
2. ✅ 本地检测会使用首次检测时间（`firstDetectedTime`）作为时间戳
3. ✅ 本地检测会比对 objectGUID，避免重复更新

**代码位置**：`Modules/TeamMessageReader.lua` 第 294-298 行

### 4. 飞到空投地图后的处理

**判断逻辑**（Timer.lua 第 360-396 行）：
1. ✅ 检查团队时间共享功能是否启用
   - 如果关闭，不判断，直接走首次检测逻辑
2. ✅ 检查时间戳是否相同
   - `currentAirdropTimestamp` 和 `lastRefresh` 相同（允许1秒误差）
   - 说明是通过团队时间共享更新的
3. ✅ 检查是否是旧空投
   - 距离当前时间超过30秒
4. ✅ 检查 objectGUID 是否不同
   - 如果不同，说明是新空投，应该正常处理（不走团队时间共享逻辑）
   - 如果相同或不存在，可能是通过团队时间共享更新的旧空投

**处理方式**：
- ✅ 如果已通过团队时间共享更新：
  - 检查30秒通知限制（基于团队消息更新的时间）
  - 不更新 `lastRefresh`（保持团队消息更新的时间）
  - 只补齐 `currentAirdropObjectGUID` 和 `lastRefreshPhase`
  - 更新 `currentAirdropTimestamp`（匹配新的空投事件）
- ✅ 如果未通过团队时间共享更新（首次检测）：
  - 无条件发送通知
  - 更新 `lastRefresh = firstDetectedTime`
  - 更新所有空投信息

---

## 三、潜在问题检查

### 1. 30秒时间窗口检查（TeamMessageReader.lua 第256-271行）

**当前逻辑**：
```lua
if timeSinceLastUpdate <= 30 and currentTime > mapData.currentAirdropTimestamp then
    -- 跳过更新
end
```

**分析**：
- ✅ 这个逻辑是合理的
- ✅ 防止同一空投的多次消息重复更新
- ✅ 如果新消息在30秒内，且新时间更晚，说明是同一空投的多次消息，应该跳过
- ✅ 如果新消息超过30秒，或者新时间更早，应该更新（可能是新的空投事件）

**结论**：逻辑正确，符合设计要求

### 2. 重载后比对（Timer.lua 第305-313行）

**当前逻辑**：
- 仅在团队时间共享功能启用时执行
- 比对 `currentAirdropObjectGUID` 和检测到的 `objectGUID`
- 如果相同，跳过处理（同一事件）

**分析**：
- ✅ 逻辑正确
- ✅ 防止重载后重复检测同一空投事件
- ✅ 仅在功能启用时执行，符合设计要求

**结论**：逻辑正确，符合设计要求

### 3. 判断是否已通过团队时间共享更新（Timer.lua 第360-396行）

**当前逻辑**：
1. 检查功能是否启用
2. 检查时间戳是否相同（`currentAirdropTimestamp == lastRefresh`，允许1秒误差）
3. 检查是否是旧空投（距离当前时间超过30秒）
4. 检查 objectGUID 是否不同（如果不同，说明是新空投）

**分析**：
- ✅ 逻辑正确
- ✅ 准确判断是否已通过团队时间共享更新
- ✅ 正确处理新空投事件（objectGUID 不同）

**结论**：逻辑正确，符合设计要求

---

## 四、完整流程验证

### 场景1：不在空投地图的玩家收到团队消息

```
1. 收到团队消息
   ├─ 检查功能开关：✅ 已启用
   ├─ 解析消息：✅ 提取地图名称
   ├─ 跳过自己消息：✅ 检查通过
   └─ 检查是否在空投地图：❌ 不在

2. 处理团队消息
   ├─ 检查30秒时间窗口：✅ 防止重复更新
   ├─ 无条件更新时间：✅ lastRefresh = currentTime
   ├─ 更新 currentAirdropTimestamp：✅ currentTime
   ├─ 清空 currentAirdropObjectGUID：✅ nil（等待补齐）
   └─ 保存数据：✅ 保存到 SavedVariables
```

### 场景2：不在空投地图的玩家飞到空投地图后

```
1. 检测到空投图标
   ├─ objectGUID 比对：✅ 不同（新事件）
   ├─ 2秒确认：✅ 通过
   └─ 判断是否已通过团队时间共享更新：✅ 是

2. 处理空投事件
   ├─ 检查30秒通知限制：✅ 基于团队消息更新的时间
   ├─ 发送通知：✅ 如果需要（未超过30秒）
   ├─ 不更新 lastRefresh：✅ 保持团队消息更新的时间
   ├─ 补齐 objectGUID：✅ currentAirdropObjectGUID = objectGUID
   ├─ 更新 currentAirdropTimestamp：✅ firstDetectedTime
   └─ 提取位面ID：✅ lastRefreshPhase = ExtractPhaseID(objectGUID)
```

### 场景3：在空投地图的玩家首次检测

```
1. 检测到空投图标
   ├─ objectGUID 比对：✅ 不同（新事件）
   ├─ 2秒确认：✅ 通过
   └─ 判断是否已通过团队时间共享更新：❌ 否（首次检测）

2. 处理空投事件
   ├─ 无条件发送通知：✅ 不需要30秒限制
   ├─ 更新 lastRefresh：✅ firstDetectedTime
   ├─ 更新 currentAirdropObjectGUID：✅ objectGUID
   ├─ 更新 currentAirdropTimestamp：✅ firstDetectedTime
   └─ 提取位面ID：✅ lastRefreshPhase = ExtractPhaseID(objectGUID)
```

---

## 五、总结

### ✅ 命令开关有效性
- **完全有效**：所有检查点都正确检查开关状态
- **默认关闭**：符合测试功能的设计要求
- **命令正确**：`/ctk timeshare on/off` 可以正确开启/关闭功能

### ✅ 团队时间共享机制
- **逻辑正确**：所有处理逻辑都符合设计要求
- **边界情况处理**：正确处理各种边界情况
- **数据一致性**：确保数据更新的一致性

### ✅ 关键设计原则
1. **单次更新原则**：一个空投事件只允许更新一次时间
2. **无条件更新**：不在空投地图的玩家收到团队消息后无条件更新
3. **补齐信息**：飞到空投地图后补齐缺失的 objectGUID 和位面ID
4. **防止重复**：30秒时间窗口防止同一空投的多次消息重复更新

### ✅ 所有检查点
- ✅ 命令开关检查（3个位置）
- ✅ 消息过滤（自己消息、功能开关）
- ✅ 不在空投地图的处理逻辑
- ✅ 在空投地图的处理逻辑
- ✅ 飞到空投地图后的判断逻辑
- ✅ 30秒时间窗口检查
- ✅ 重载后比对逻辑
- ✅ 判断是否已通过团队时间共享更新

---

**确认时间**：2024-12-29  
**确认结果**：✅ 所有机制正确，符合设计要求，命令开关有效

