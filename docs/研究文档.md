# CrateTrackerZK 研究文档

## 目录

1. [GUID 与位面ID研究](#guid-与位面id研究)
2. [空投检测与通知机制详解](#空投检测与通知机制详解)
3. [防误报机制](#防误报机制)
4. [团队消息读取机制](#团队消息读取机制)

---

## GUID 与位面ID研究

### GUID 基本概念

**GUID (Global Unique Identifier)** 是魔兽世界中用于唯一标识游戏对象的字符串标识符。每个游戏对象（NPC、玩家、物品、Vignette图标等）都有一个唯一的GUID。

#### GUID 与 objectGUID 的区别

在空投检测中，我们遇到两种GUID：

1. **GUID**：Vignette图标的GUID，用于地图上的图标显示
2. **objectGUID**：实际游戏对象的GUID，代表真实的游戏实体（如飞机、箱子等）

**关系**：
- 一个Vignette图标（GUID）可以关联到一个实际游戏对象（objectGUID）
- 它们属于同一个游戏事件，因此某些字段相同（分片ID、实例ID、ZoneUID、SpawnUID）
- 但类型和ID部分不同（Vignette ID vs NPC ID）

### GUID 结构分析

#### GUID 格式

根据 [Wowpedia GUID 文档](https://wowpedia.fandom.com/wiki/GUID)，GUID的标准格式为：

```
Type-ServerID-InstanceID-ZoneUID-ID-SpawnID
```

以 Creature（生物）类型的GUID为例：

```
Creature-0-[分片ID]-[实例ID]-[zoneUID]-[NPC ID]-[spawnUID]
```

**各部分说明**：

| 位置 | 名称 | 说明 | 固定性 | 示例值 |
|------|------|------|--------|--------|
| 1 | Type | 对象类型 | **固定**（取决于对象类型） | `Creature`, `Vehicle`, `Vignette` 等 |
| 2 | 固定值 | 通常为 `0` | **固定** | `0` |
| 3 | 分片ID (ShardID) | 服务器分片标识符 | **变化**（每次位面不同） | `3149`, `3907`, `2139` |
| 4 | 实例ID (InstanceID) | 实例/位面标识符 | **变化**（每次位面不同） | `2552`, `2127`, `2601` |
| 5 | ZoneUID | 区域唯一标识符 | **固定**（同一区域相同） | `12`, `92` |
| 6 | ID | 模板ID（NPC ID / Vignette ID） | **固定**（同一类型对象相同） | `135181`（NPC）, `3689`（Vignette） |
| 7 | SpawnUID | 生成唯一标识符 | **变化**（每次生成不同） | `0000527FA0`, `0000533CCC` |

#### 实际数据示例

**空投事件 - GUID 和 objectGUID 对比**（陨圣峪空投事件）：

```
GUID: Vignette-0-2139-2601-92-3689-0000533CCC
objectGUID: Creature-0-2139-2601-92-135181-0000533CCC
```

**详细解析**：

| 字段 | GUID (Vignette) | objectGUID (Creature) | 说明 |
|------|-----------------|----------------------|------|
| Type | `Vignette` | `Creature` | 不同类型：图标 vs 实际对象 |
| 固定值 | `0` | `0` | 固定 |
| 分片ID | `2139` | `2139` | **相同**（同一位面） |
| 实例ID | `2601` | `2601` | **相同**（同一位面） |
| ZoneUID | `92` | `92` | **相同**（同一区域） |
| ID | `3689` (Vignette ID) | `135181` (NPC ID) | **不同**（不同类型） |
| SpawnUID | `0000533CCC` | `0000533CCC` | **相同**（同一生成事件） |

**关键发现**：
- ✅ **相同字段**：分片ID、实例ID、ZoneUID、SpawnUID（因为它们属于同一个空投事件）
- ❌ **不同字段**：Type（Vignette vs Creature）、ID部分（3689 vs 135181）

### 位面ID解析

#### 位面ID的定义

**位面ID (Phase ID)** 用于标识玩家所在的特定"位面"或"实例"。同一位面的玩家可以看到相同的游戏内容，不同位面的玩家即使在同一位置也可能看到不同的内容。

#### 位面ID的组成

根据研究，位面ID由两部分组成：

```
位面ID = 分片ID + "-" + 实例ID
```

即：**第3部分 + "-" + 第4部分**

#### 为什么分片ID是关键

通过实际数据观察：

| 角色 | 位面ID | 分片ID | 实例ID | 说明 |
|------|--------|--------|--------|------|
| 大号 | `3149-2552` | `3149` | `2552` | 位面1 |
| 小号 | `3907-2552` | `3907` | `2552` | 位面2（不同位面） |
| 大号（组队后） | `3149-2552` | `3149` | `2552` | 同一位面 |
| 小号（组队后） | `3149-2552` | `3149` | `2552` | 同一位面 |

**结论**：
- 不同位面时，**分片ID不同**（`3149` vs `3907`）
- 同一位面时，**分片ID相同**（`3149`）
- 实例ID可能相同（`2552`），不能单独用于区分位面
- **分片ID是区分位面的关键标识**

#### 错误解析与修复

**之前的错误解析**（已修复）：

```lua
-- 错误：使用分片ID-zoneUID（第3部分-第5部分）
local unitType, _, serverID, _, layerUID = strsplit("-", guid);
if (unitType == "Creature" or unitType == "Vehicle") and serverID and layerUID then
    return serverID .. "-" .. layerUID;  -- 错误！
end
```

**正确的解析方法**（当前实现）：

```lua
-- 正确：使用分片ID-实例ID（第3部分-第4部分）
local unitType, _, shardID, instanceID = strsplit("-", guid);
if (unitType == "Creature" or unitType == "Vehicle") and shardID and instanceID then
    return shardID .. "-" .. instanceID;  -- 正确！
end
```

**修复位置**：`Modules/Phase.lua` 的 `GetLayerFromNPC()` 函数

---

## 空投检测与通知机制详解

### 核心机制概览

#### 主要组件

- **TimerManager** (`Modules/Timer.lua`): 核心检测循环协调器，每1秒执行一次检测
- **IconDetector** (`Modules/IconDetector.lua`): 地图图标检测器，检测空投箱子图标，返回完整的 objectGUID
- **Notification** (`Modules/Notification.lua`): 通知系统，处理自动和手动通知
- **Data** (`Data/Data.lua`): 数据管理器，处理刷新时间的更新和计算

#### 检测机制

检测机制包含以下核心要素：

- **objectGUID 去重**：通过比对完整的 objectGUID 识别同一空投事件，防止重复检测
- **2秒确认期**：首次检测到图标后，需要持续检测2秒才确认
- **30秒通知限制**：空投开始后30秒内才允许发送通知（基于 `currentAirdropTimestamp`）

### 完整执行流程

#### 检测循环流程（每1秒执行）

```
TimerManager:DetectMapIcons()  // 每1秒执行
│
├─ 1. 获取当前地图ID
│   └─ currentMapID = C_Map.GetBestMapForUnit("player")
│
├─ 2. 匹配目标地图数据
│   └─ targetMapData = MapTracker:GetTargetMapData(currentMapID)
│       ├─ 首先匹配当前地图ID
│       └─ 如果未匹配，尝试匹配父地图ID
│
├─ 3. 处理地图变化
│   └─ MapTracker:OnMapChanged(currentMapID, targetMapData, currentTime)
│
├─ 4. 检测图标
│   └─ iconResult = IconDetector:DetectIcon(currentMapID)
│       ├─ 获取所有Vignette图标: C_VignetteInfo.GetVignettes()
│       ├─ 遍历查找空投箱子（通过名称匹配）
│       ├─ 优先检测飞机图标（vignetteID = 3689）
│       ├─ 提取 objectGUID 和 SpawnUID
│       └─ 返回 {detected, objectGUID, spawnUID, vignetteGUID, vignetteID}
│
├─ 5. SpawnUID 比对（去重机制）
│   └─ if targetMapData.currentAirdropSpawnUID == spawnUID
│       └─ return true  // 同一事件，跳过处理
│
├─ 6. 首次检测或新事件
│   └─ if not detectionState[mapId]
│       ├─ 记录首次检测时间：firstDetectedTime = currentTime
│       ├─ 记录 SpawnUID：detectedSpawnUID = spawnUID
│       └─ return true  // 等待2秒确认
│
├─ 7. 检查 SpawnUID 是否变化
│   └─ if detectionState.detectedSpawnUID ~= spawnUID
│       └─ 检测到新事件，重新开始检测
│
└─ 8. 2秒确认机制
    └─ if (currentTime - firstDetectedTime) >= 2秒
        ├─ 重新检测图标（双重验证）
        ├─ 确认 objectGUID 仍然相同
        ├─ 检查30秒通知限制（基于 currentAirdropTimestamp）
        ├─ 发送通知（如果需要）
        ├─ 更新刷新时间
        ├─ 更新 currentAirdropObjectGUID 和 currentAirdropTimestamp
        └─ 清除检测状态
```

### objectGUID 去重机制详解

#### 核心原理

**objectGUID 是什么**：
- objectGUID 是完整的游戏对象标识符（Global Unique Identifier）
- 每次空投事件生成时，objectGUID 都是唯一的
- 同一空投事件的 objectGUID 在整个事件生命周期内保持不变
- 格式：`Creature-0-[分片ID]-[实例ID]-[zoneUID]-[NPC ID]-[spawnUID]`

**去重逻辑**：
1. 检测到图标时，获取完整的 objectGUID
2. 与 `mapData.currentAirdropObjectGUID` 比对
3. 如果相同，跳过处理（同一事件）
4. 如果不同或不存在，视为新事件，开始检测流程

**数据存储**：
- `currentAirdropObjectGUID`：当前空投事件的完整 objectGUID（持久化）
- `currentAirdropTimestamp`：当前空投事件的时间戳（持久化）
- `detectionState[mapId]`：检测状态（内存，不持久化）
  - `firstDetectedTime`：首次检测时间
  - `detectedObjectGUID`：检测到的 objectGUID

**优势**：
- 使用完整的 objectGUID 比对，比仅使用 SpawnUID 更准确
- 可以从 objectGUID 中提取位面信息，无需单独存储

---

## 防误报机制

### 核心防护机制

#### 1. 2秒确认期（CONFIRM_TIME）

**位置**：`Modules/Timer.lua:37`

**机制**：
- 首次检测到图标时，记录 `firstDetectedTime` 和 `objectGUID`
- 图标必须**持续存在至少2秒**才能确认空投事件
- 如果图标在2秒内消失，判定为无效空投，清除检测状态

**防护效果**：
- ✅ 防止短暂图标闪烁导致的误报
- ✅ 确保只有持续存在的图标才会被确认

#### 2. objectGUID 比对去重

**位置**：`Modules/Timer.lua:268-274`

**机制**：
- 检测到图标时，获取完整的 objectGUID
- 与 `mapData.currentAirdropObjectGUID` 比对
- 如果相同，跳过处理（同一事件）

**防护效果**：
- ✅ 防止同一空投事件重复检测和通知
- ✅ 支持传送中断后恢复检测的场景

#### 3. 重新检测验证（双重验证）

**位置**：`Modules/Timer.lua:331-337`

**机制**：
- 在2秒确认后，**重新检测图标是否仍然存在**
- 确认 objectGUID 仍然相同
- 如果重新检测时图标已消失或 objectGUID 不同，发送无效空投系统消息并跳过处理

**无效空投通知**：
- 当检测到无效空投事件时，发送系统消息："【地图名】 检测到无效空投事件，空投飞机存在时间过短，判定为无效事件。"
- 只发送系统消息（聊天框），不发送团队通知
- 帮助用户了解为什么某些空投事件没有被记录

**防护效果**：
- ✅ 防止在确认过程中图标消失导致的误报
- ✅ 确保处理时图标确实存在且是同一事件
- ✅ 通过系统消息提醒用户无效空投事件

#### 4. 30秒通知限制

**位置**：`Modules/Timer.lua:216-223`

**机制**：
- 基于 `mapData.currentAirdropTimestamp`（空投事件开始时间戳）
- 计算：`timeSinceAirdrop = currentTime - currentAirdropTimestamp`
- 如果 `timeSinceAirdrop <= 30秒`，允许发送通知
- 如果 `timeSinceAirdrop > 30秒`，不发送通知

**防护效果**：
- ✅ 防止空投开始后很久才进入地图的玩家发送通知
- ✅ 避免干扰其他玩家

#### 5. 区域有效性检查

**位置**：`Modules/Area.lua`

**机制**：
- 检查玩家是否在副本/战场中（自动暂停检测）
- 检查当前地图是否在追踪列表中
- 支持父地图匹配

**防护效果**：
- ✅ 防止在无效区域检测导致的误报
- ✅ 确保只在正确的追踪区域进行检测

#### 6. 团队消息冷却期

**位置**：`Modules/Timer.lua:280-299`

**机制**：
- 检查是否在30秒内收到过团队消息
- 如果收到过，不发送重复通知（但会更新刷新时间）
- 如果超过30秒，不再发送通知（因为空投已经发生30秒了，再发没意义）

**防护效果**：
- ✅ 防止团队成员重复发送通知
- ✅ 避免通知刷屏

### 完整检测流程

#### 正常检测流程

```
1. 检测循环（每秒）
   ├─ 检查区域有效性
   └─ 检测图标（返回完整的 objectGUID）

2. objectGUID 比对
   ├─ 检查是否是已知事件（currentAirdropObjectGUID == objectGUID）
   └─ 如果相同，跳过处理

3. 首次检测或新事件
   ├─ 记录首次检测时间：firstDetectedTime
   └─ 记录 objectGUID：detectedObjectGUID
   └─ 等待2秒确认

4. 2秒确认机制
   ├─ 持续检测2秒
   ├─ 重新检测图标（双重验证）
   ├─ 确认 objectGUID 仍然相同
   └─ 检查30秒通知限制

5. 处理确认的空投事件
   ├─ 发送通知（如果需要）
   ├─ 更新刷新时间
   ├─ 更新 currentAirdropObjectGUID 和 currentAirdropTimestamp
   └─ 清除检测状态
```

#### 误报防护流程

```
1. 短暂图标闪烁
   ├─ 检测到图标，记录 firstDetectedTime
   ├─ 图标消失（<2秒）
   ├─ 发送无效空投系统消息："【地图名】 检测到无效空投事件，空投飞机存在时间过短，判定为无效事件。"
   └─ 清除检测状态（无效空投，只发送系统消息，不发送团队通知）

2. 图标在确认后消失
   ├─ 检测到图标，记录 firstDetectedTime
   ├─ 持续2秒
   ├─ 重新检测图标（已消失或 objectGUID 不同）
   ├─ 发送无效空投系统消息："【地图名】 检测到无效空投事件，空投飞机存在时间过短，判定为无效事件。"
   └─ 跳过处理，清除检测状态（无效空投，只发送系统消息，不发送团队通知）

3. 重复检测防护
   ├─ 检测到图标，获取完整的 objectGUID
   ├─ 比对 currentAirdropObjectGUID
   └─ 如果相同，跳过处理（同一事件）
```

### 防护机制总结

| 机制 | 位置 | 防护效果 | 重要性 |
|------|------|----------|--------|
| 2秒确认期 | Timer.lua | 防止短暂闪烁误报 | ⭐⭐⭐⭐⭐ |
| objectGUID 比对 | Timer.lua | 防止重复检测 | ⭐⭐⭐⭐⭐ |
| 重新检测验证 | Timer.lua | 防止状态转换时误报 | ⭐⭐⭐⭐⭐ |
| 30秒通知限制 | Timer.lua | 防止过期通知 | ⭐⭐⭐⭐ |
| 区域有效性 | Area.lua | 防止无效区域检测 | ⭐⭐⭐⭐ |

---

## 团队消息读取机制

### 功能概述

团队消息读取功能允许插件监听团队/小队聊天中的空投消息，自动更新对应地图的刷新时间，无论玩家是否在该地图上。

**主要特性**:
- 自动识别插件发送的空投消息（通过消息格式匹配）
- 支持多语言消息格式识别
- 自动更新刷新时间（使用消息发送时间）
- 防止重复更新（时间窗口检查、自己发送的消息检查、objectGUID比对）
- 30秒通知限制（基于 currentAirdropTimestamp）

### 完整执行流程

#### 初始化流程

**触发时机**: `PLAYER_LOGIN` 事件或首次调用 `ProcessTeamMessage`

**执行步骤**:

```
1. TeamMessageReader:Initialize()
   ├─ 清除所有内存状态（防止跨角色污染）
   │   └─ lastTeamMessageTime = {}
   │
   ├─ 初始化消息模式
   │   └─ InitializeMessagePatterns()
   │       ├─ 从 LocaleManager 获取所有已注册的语言
   │       ├─ 遍历所有语言，提取 AirdropDetected 格式
   │       ├─ 去重（避免重复的消息格式）
   │       └─ 为每个消息格式创建匹配模式
   │           ├─ 转义特殊字符
   │           └─ 将 %s 替换为 (.+) 来匹配地图名称
   │
   └─ 注册聊天消息监听
       └─ 创建聊天框架并注册事件
           ├─ CHAT_MSG_RAID
           ├─ CHAT_MSG_RAID_WARNING
           ├─ CHAT_MSG_PARTY
           └─ CHAT_MSG_INSTANCE_CHAT
```

#### 消息处理流程

```
TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
│
├─ 1. 参数验证
│   ├─ 检查 message 是否为字符串
│   └─ 检查 chatType 是否为团队/小队消息类型
│
├─ 2. 检查是否是自动消息
│   └─ IsAutoMessage(message)
│       ├─ 遍历所有消息模式
│       └─ 如果匹配 AirdropDetected 格式，返回 true
│
├─ 3. 解析消息，提取地图名称
│   └─ ParseTeamMessage(message)
│       ├─ 调用 IsAutoMessage() 确认是自动消息
│       ├─ 遍历所有消息模式，匹配地图名称
│       └─ 返回地图名称（去除首尾空格）
│
├─ 4. 根据地图名称获取地图ID
│   └─ GetMapIdByName(mapName)
│       ├─ 首先使用当前语言的地图名称匹配
│       └─ 如果失败，遍历所有语言的地图名称匹配
│
├─ 5. 检查是否是当前玩家发送的消息（防重复更新 #1）
│   └─ if sender == playerName or sender == fullPlayerName then
│       └─ return false  // 是自己发送的消息，不处理
│
├─ 6. 检查是否是同一事件（objectGUID比对）
│   └─ if mapData.currentAirdropObjectGUID == objectGUID（从消息中提取）
│       └─ return false  // 同一事件，跳过处理
│
├─ 7. 记录收到团队消息的时间
│   └─ lastTeamMessageTime[mapId] = currentTime
│       └─ 用于防止之后进入地图时重复通知
│
├─ 8. 检查是否应该更新刷新时间（防重复更新 #3）
│   └─ 时间窗口检查
│       ├─ 获取旧时间: oldTime = Data:GetMap(mapId).lastRefresh
│       ├─ 计算时间差异: timeDiff = math.abs(currentTime - oldTime)
│       └─ if timeDiff <= 30 then
│           └─ 时间差异在30秒内，视为同一空投
│               ├─ if currentTime < oldTime then
│               │   └─ refreshTime = currentTime  // 使用更早的时间
│               └─ else
│                   └─ shouldUpdate = false  // 保持旧时间（不更新）
│
├─ 9. 更新刷新时间（如果需要）
│   └─ if shouldUpdate then
│       └─ Data:SetLastRefresh(mapId, refreshTime)
│           ├─ mapData.lastRefresh = refreshTime
│           ├─ Data:UpdateNextRefresh(mapId)
│           └─ Data:SaveMapData(mapId)
│
├─ 10. 更新UI
│    └─ TimerManager:UpdateUI()
│        └─ MainPanel:UpdateTable()
│
└─ 11. 更新空投事件信息
    ├─ 更新 currentAirdropObjectGUID（如果消息中包含）
    └─ 更新 currentAirdropTimestamp
```

### 消息格式识别机制

#### 消息格式区分

**自动消息格式** (AirdropDetected):
- 中文简体: `【%s】 检测到战争物资正在空投！！！`
- 中文繁体: `【%s】 檢測到戰爭物資正在空投！！！`
- 英文: `[%s] Detected War Supplies airdrop!!!`
- 俄文: `[%s] Обнаружен сброс военных припасов!!!`

**手动消息格式** (AirdropDetectedManual):
- 中文简体: `【%s】 战争物资正在空投！！！`
- 中文繁体: `【%s】 戰爭物資正在空投！！！`
- 英文: `[%s] War Supply Crate airdrop in progress!!!`
- 俄文: `[%s] Сброс военных припасов в процессе!!!`

**区别**: 自动消息包含"检测到"关键字，手动消息不包含。

#### 识别逻辑

`TeamMessageReader` 模块负责识别团队中的自动检测消息，并用于防止重复通知。

**识别流程**：

1. **检查是否是自动消息**：
   - 通过匹配 `AirdropDetected` 格式来判断是否是自动消息
   - 如果匹配成功，返回 true（是自动消息）
   - 否则返回 false（可能是手动消息，跳过处理）

2. **提取地图名称**：
   - 只处理自动消息（匹配 `AirdropDetected` 格式的消息）
   - 尝试匹配所有已加载的消息模式
   - 如果匹配成功，返回地图名称

### 防止重复更新机制

#### 1. 自己发送的消息检查

如果消息发送者是当前玩家，跳过处理（不更新刷新时间）。

#### 2. SpawnUID比对

如果消息中的 SpawnUID 与本地记录的相同，跳过处理（同一事件）。

#### 3. 时间窗口检查

如果时间差异在30秒内，视为同一空投：
- 如果新时间更早，使用新时间（更准确）
- 如果新时间更晚，保持旧时间（不更新）

---

**最后更新**：2024-12-29  
**维护者**：capzk

---

## 最新更新（2024-12-29）

### 位面检测系统消息提醒
- 首次获取到位面ID时发送系统消息："【地图名】当前位面ID：|cffffff00XX|r"
- 位面发生变化时发送系统消息："【地图名】当前位面ID已变更为：|cffffff00XX|r"
- 所有消息已本地化（zhCN/zhTW/enUS/ruRU）

### 无效空投提示简化
- 统一为一条系统消息："【地图名】 检测到无效空投事件，空投飞机存在时间过短，判定为无效事件。"
- 移除详细原因说明（图标消失时间、SpawnUID变化等）
- 只发送系统消息，不发送团队通知

