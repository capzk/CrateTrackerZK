# 自己发送的消息导致重复更新

## 问题描述

**日期**: 2024-12-19  
**版本**: 1.1.3+  
**严重程度**: 中  
**状态**: ✅ 已修复

### 症状

当玩家自己发送自动检测消息到团队频道时，自己的 `TeamMessageReader` 也会识别这条消息并更新刷新时间，导致重复更新。

### 复现步骤

1. 玩家在某个地图（如喧鸣深窟）检测到空投
2. 插件自动发送团队消息：`【喧鸣深窟】 检测到战争物资正在空投！！！`
3. 自己的 `TeamMessageReader` 监听到这条消息
4. `TeamMessageReader` 识别到这是自动消息，更新了刷新时间
5. 但实际上 `Timer.lua` 已经更新过刷新时间了，导致重复更新

### 日志示例

```
[12:08] [CrateTrackerZK|通知|通知] 【喧鸣深窟】 检测到战争物资正在空投！！！
[12:08] [团队通知] [忆川]： 【喧鸣深窟】 检测到战争物资正在空投！！！
[12:08] [CrateTrackerZK|TeamMessageReader|更新] 已根据团队消息更新刷新时间：地图=喧鸣深窟，时间=12:08:26
```

## 问题分析

### 根本原因

`TeamMessageReader` 模块监听所有团队消息，包括自己发送的消息。当自己发送自动检测消息时，`TeamMessageReader` 无法区分这是自己发送的还是其他玩家发送的，导致重复处理。

### 问题代码位置

**Modules/TeamMessageReader.lua** - `ProcessTeamMessage` 函数

```lua
function TeamMessageReader:ProcessTeamMessage(message, chatType, sender)
    -- ... 解析消息 ...
    
    -- 直接更新刷新时间，没有检查是否是自己发送的消息
    local success = Data:SetLastRefresh(mapId, currentTime);
    -- ...
end
```

### 问题流程

```
玩家检测到空投
  ↓
Timer.lua 更新刷新时间 ✅
  ↓
Notification.lua 发送团队消息
  ↓
TeamMessageReader 监听到消息
  ↓
识别为自动消息
  ↓
再次更新刷新时间 ❌（重复更新）
```

## 解决方案

### 修复内容

#### 1. 检查发送者是否是当前玩家

在 `ProcessTeamMessage` 函数中添加发送者检查：

```lua
-- 检查是否是当前玩家发送的消息（避免重复更新）
local playerName = UnitName("player");
local realmName = GetRealmName();
local fullPlayerName = playerName;
if realmName then
    fullPlayerName = playerName .. "-" .. realmName;
end

-- 检查发送者是否是当前玩家（支持带服务器名和不带服务器名的格式）
if sender and (sender == playerName or sender == fullPlayerName) then
    if Logger and Logger.Debug then
        Logger:Debug("TeamMessageReader", "处理", string.format("跳过自己发送的消息：发送者=%s，地图=%s", sender, mapName));
    end
    return false;  -- 是自己发送的消息，不处理
end
```

#### 2. 检查当前地图的 PROCESSED 状态

如果当前地图已经是 `PROCESSED` 状态，说明是自己检测到的，跳过处理：

```lua
-- 检查当前地图是否已经是 PROCESSED 状态（说明已经处理过了，避免重复更新）
if DetectionState then
    local state = DetectionState:GetState(mapId);
    if state and state.status == DetectionState.STATES.PROCESSED then
        -- 检查是否是当前地图（如果是当前地图且是 PROCESSED 状态，说明是自己检测到的，跳过）
        local currentMapID = C_Map and C_Map.GetBestMapForUnit and C_Map.GetBestMapForUnit("player");
        local mapData = Data:GetMap(mapId);
        local isOnMap = mapData and currentMapID == mapData.mapID;
        if isOnMap then
            if Logger and Logger.Debug then
                Logger:Debug("TeamMessageReader", "处理", string.format("跳过当前地图的PROCESSED状态消息（可能是自己发送的）：地图=%s，发送者=%s", mapName, sender or "未知"));
            end
            return false;  -- 当前地图且是 PROCESSED 状态，可能是自己发送的，跳过
        end
    end
end
```

### 修复后的流程

```
玩家检测到空投
  ↓
Timer.lua 更新刷新时间 ✅
  ↓
Notification.lua 发送团队消息
  ↓
TeamMessageReader 监听到消息
  ↓
检查发送者是否是当前玩家？
  ├─ 是 → 跳过处理 ✅（避免重复更新）
  └─ 否 → 继续
  ↓
检查当前地图是否是 PROCESSED 状态？
  ├─ 是且是当前地图 → 跳过处理 ✅（可能是自己发送的）
  └─ 否 → 继续
  ↓
更新刷新时间 ✅（只有其他玩家的消息才会更新）
```

## 技术细节

### 玩家名称格式

WoW 中的玩家名称可能有两种格式：
1. **不带服务器名**：`忆川`
2. **带服务器名**：`忆川-服务器名`

修复代码同时支持这两种格式，确保正确识别。

### 双重检查机制

1. **发送者检查**：直接比较发送者名称，最直接有效
2. **状态检查**：如果发送者检查失败（例如名称格式不匹配），通过 `PROCESSED` 状态作为备用检查

### 为什么需要双重检查

- **发送者检查**：主要检查，直接有效
- **状态检查**：备用检查，防止发送者检查失败的情况（例如名称格式问题、跨服务器等）

## 测试验证

### 测试步骤

1. ✅ 玩家在某个地图检测到空投
2. ✅ 插件自动发送团队消息
3. ✅ 验证自己的 `TeamMessageReader` 不会处理这条消息
4. ✅ 验证刷新时间只更新一次（由 `Timer.lua` 更新）
5. ✅ 验证其他玩家发送的消息正常处理

### 预期结果

- ✅ 自己发送的消息不会被自己的 `TeamMessageReader` 处理
- ✅ 避免重复更新刷新时间
- ✅ 其他玩家的消息正常处理
- ✅ 支持带服务器名和不带服务器名的玩家名称格式

## 相关文件

- `Modules/TeamMessageReader.lua` - 团队消息读取逻辑
- `Modules/Notification.lua` - 消息发送逻辑
- `Modules/Timer.lua` - 检测和更新逻辑
- `Modules/DetectionState.lua` - 检测状态管理

## 总结

这个问题是由于 `TeamMessageReader` 无法区分自己发送的消息和其他玩家发送的消息导致的。修复方案是添加双重检查机制：
1. 检查发送者是否是当前玩家
2. 检查当前地图是否已经是 `PROCESSED` 状态

这样既保证了其他玩家的消息正常处理，又避免了自己发送的消息导致重复更新。

---

**修复提交**: 2024-12-19  
**修复版本**: 1.1.3+  
**修复者**: AI Assistant (Auto)

