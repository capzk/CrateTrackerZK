# 多用户消息导致重复更新

## 问题描述

**日期**: 2025-12-29  
**版本**: 1.1.4.20251229_beta  
**严重程度**: 中  
**状态**: ✅ 已修复

### 症状

当团队中多个用户插件在不同时间发送空投消息时，`TeamMessageReader` 会不断更新刷新时间为最新的时间，而不是使用最早的时间（空投实际开始的时间）。

### 复现步骤

1. 用户A在某个地图（如多恩岛）检测到空投，在 12:00:00 发送团队消息
2. 用户B在 12:00:05 也检测到空投，发送团队消息
3. 用户C在 12:00:10 也检测到空投，发送团队消息
4. 其他用户的 `TeamMessageReader` 会依次处理这些消息：
   - 收到用户A的消息 → 更新刷新时间为 12:00:00 ✅
   - 收到用户B的消息 → 更新刷新时间为 12:00:05 ❌（覆盖了12:00:00）
   - 收到用户C的消息 → 更新刷新时间为 12:00:10 ❌（覆盖了12:00:05）

### 问题影响

- **刷新时间不准确**：刷新时间被更新为最新的检测时间，而不是空投实际开始的时间
- **下次刷新时间计算错误**：基于错误的刷新时间计算出的下次刷新时间也会不准确
- **影响所有团队成员**：所有使用插件的团队成员都会受到影响

## 问题分析

### 根本原因

`TeamMessageReader:ProcessTeamMessage` 函数在收到团队消息时，直接调用 `Data:SetLastRefresh(mapId, currentTime)` 更新刷新时间，没有检查：

1. **时间窗口**：是否在短时间内（如30秒内）已经更新过
2. **时间比较**：如果已经更新过，新时间是否比旧时间更早（应该使用更早的时间）

### 当前防重复机制

**已有的机制**：
1. ✅ **自己发送的消息检查**（第273-278行）：跳过自己发送的消息
2. ✅ **PROCESSED 状态检查**（第280-295行）：如果当前地图已经是 PROCESSED 状态，跳过处理
3. ⚠️ **lastTeamMessageTime 记录**（第305行）：记录收到团队消息的时间，但**只用于防止重复通知，不用于防止重复更新**

**缺失的机制**：
1. ❌ **时间窗口检查**：没有检查距离上次更新是否在冷却期内
2. ❌ **时间比较**：没有比较新时间和旧时间，使用更早的时间

### 问题代码位置

**Modules/TeamMessageReader.lua** - `ProcessTeamMessage` 函数（第302-318行）

```lua
local currentTime = time();

-- 记录收到团队消息的时间（用于防止之后进入地图时重复通知）
TeamMessageReader.lastTeamMessageTime[mapId] = currentTime;

-- 更新刷新时间（使用当前时间作为刷新时间）
local success = Data:SetLastRefresh(mapId, currentTime);
```

**问题**：
- 每次收到消息都直接更新刷新时间，没有检查是否在冷却期内
- 没有比较新时间和旧时间，使用更早的时间

### 问题流程

```
用户A在12:00:00发送消息
  ↓
TeamMessageReader收到消息
  ↓
更新刷新时间为12:00:00 ✅
  ↓
用户B在12:00:05发送消息
  ↓
TeamMessageReader收到消息
  ↓
更新刷新时间为12:00:05 ❌（覆盖了12:00:00）
  ↓
用户C在12:00:10发送消息
  ↓
TeamMessageReader收到消息
  ↓
更新刷新时间为12:00:10 ❌（覆盖了12:00:05）
```

## 解决方案

### 修复内容

#### 1. 添加时间窗口检查

在更新刷新时间之前，检查距离上次更新是否在冷却期内（30秒内）：

```lua
-- 检查是否应该更新刷新时间（防止短时间内多次更新）
local function ShouldUpdateRefreshTime(mapId, newTime)
    if not mapId or not newTime then
        return true;  -- 参数无效，允许更新
    end
    
    local mapData = Data:GetMap(mapId);
    if not mapData or not mapData.lastRefresh then
        return true;  -- 没有旧记录，允许更新
    end
    
    local oldTime = mapData.lastRefresh;
    local timeDiff = math.abs(newTime - oldTime);
    
    -- 如果时间差异在30秒内，说明是同一个空投的多次报告
    if timeDiff <= TeamMessageReader.MESSAGE_COOLDOWN then
        -- 使用更早的时间（空投实际开始的时间）
        return newTime < oldTime;  -- 只有新时间更早时才更新
    end
    
    -- 时间差异超过30秒，说明是新的空投，允许更新
    return true;
end
```

#### 2. 修改 ProcessTeamMessage 函数

在调用 `SetLastRefresh` 之前，先检查是否应该更新：

```lua
local currentTime = time();

-- 记录收到团队消息的时间（用于防止之后进入地图时重复通知）
TeamMessageReader.lastTeamMessageTime[mapId] = currentTime;

-- 检查是否应该更新刷新时间（防止短时间内多次更新）
if not ShouldUpdateRefreshTime(mapId, currentTime) then
    if Logger and Logger.Debug then
        Logger:Debug("TeamMessageReader", "更新", string.format("跳过重复更新：地图=%s，旧时间=%s，新时间=%s（时间差异在冷却期内，且新时间不更早）", 
            mapName, 
            Data:FormatDateTime(Data:GetMap(mapId).lastRefresh),
            Data:FormatDateTime(currentTime)));
    end
    return true;  -- 跳过更新，但返回true表示消息已处理
end

-- 获取旧时间（用于比较）
local mapData = Data:GetMap(mapId);
local oldTime = mapData and mapData.lastRefresh;
local timeDiff = oldTime and math.abs(currentTime - oldTime) or nil;

-- 如果时间差异在30秒内，使用更早的时间
local refreshTime = currentTime;
if timeDiff and timeDiff <= TeamMessageReader.MESSAGE_COOLDOWN and oldTime and currentTime > oldTime then
    refreshTime = oldTime;  -- 使用更早的时间
    if Logger and Logger.Debug then
        Logger:Debug("TeamMessageReader", "更新", string.format("使用更早的时间：地图=%s，旧时间=%s，新时间=%s，使用时间=%s", 
            mapName,
            Data:FormatDateTime(oldTime),
            Data:FormatDateTime(currentTime),
            Data:FormatDateTime(refreshTime)));
    end
end

-- 更新刷新时间
local success = Data:SetLastRefresh(mapId, refreshTime);
```

### 修复后的流程

```
用户A在12:00:00发送消息
  ↓
TeamMessageReader收到消息
  ↓
检查：没有旧记录，允许更新 ✅
  ↓
更新刷新时间为12:00:00 ✅
  ↓
用户B在12:00:05发送消息
  ↓
TeamMessageReader收到消息
  ↓
检查：时间差异5秒 < 30秒，且新时间12:00:05 > 旧时间12:00:00
  ↓
使用更早的时间12:00:00 ✅（不更新）
  ↓
用户C在12:00:10发送消息
  ↓
TeamMessageReader收到消息
  ↓
检查：时间差异10秒 < 30秒，且新时间12:00:10 > 旧时间12:00:00
  ↓
使用更早的时间12:00:00 ✅（不更新）
```

### 技术细节

#### 时间窗口（MESSAGE_COOLDOWN）

- **当前值**：30秒
- **用途**：
  1. 防止重复通知（已有）
  2. 防止重复更新（新增）
- **原理**：空投持续时间通常很短（几分钟），如果多个用户在30秒内报告，说明是同一个空投

#### 时间比较逻辑

- **如果时间差异 ≤ 30秒**：
  - 如果新时间 < 旧时间：更新为新时间（使用更早的时间）
  - 如果新时间 ≥ 旧时间：不更新（保持旧时间）
- **如果时间差异 > 30秒**：
  - 允许更新（说明是新的空投）

#### 边界情况

1. **没有旧记录**：允许更新（首次检测）
2. **时间差异正好30秒**：视为同一空投（使用 ≤ 判断）
3. **新时间比旧时间早很多**：如果差异 > 30秒，可能是时间同步问题，允许更新

## 测试步骤

### 测试场景1：多个用户短时间内发送消息

1. 准备3个用户（A、B、C）在同一个团队中
2. 用户A在 12:00:00 检测到空投，发送消息
3. 用户B在 12:00:05 检测到空投，发送消息
4. 用户C在 12:00:10 检测到空投，发送消息
5. **预期结果**：所有用户的刷新时间都应该是 12:00:00（最早的时间）

### 测试场景2：不同空投（时间差异 > 30秒）

1. 准备2个用户（A、B）在同一个团队中
2. 用户A在 12:00:00 检测到空投，发送消息
3. 用户B在 12:01:00（60秒后）检测到空投，发送消息
4. **预期结果**：刷新时间应该更新为 12:01:00（新的空投）

### 测试场景3：自己发送的消息

1. 用户在某个地图检测到空投，发送消息
2. **预期结果**：自己的消息被跳过，不更新刷新时间（已有机制）

### 测试场景4：当前地图 PROCESSED 状态

1. 用户在某个地图检测到空投，进入 PROCESSED 状态
2. 收到其他用户的消息
3. **预期结果**：如果消息是关于当前地图的，跳过处理（已有机制）

## 相关文件

- `Modules/TeamMessageReader.lua` - 主要修改文件
- `Data/Data.lua` - `SetLastRefresh` 函数（可能需要调整）

## 更新历史

- **2025-12-29**：创建问题文档
- **2025-12-29**：实现修复方案，添加时间窗口检查和时间比较逻辑

